<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - app/View/angularjs-nvd3-directives.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>app/View/angularjs-nvd3-directives.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.86</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2629</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">195.90</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">35.05</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*! angularjs-nvd3-directives - v0.0.2-beta - 2013-11-09
* http://cmaurer.github.io/angularjs-nvd3-directives
* Copyright (c) 2013 Christian Maurer; Licensed Apache License, v2.0 */
(function () {
    angular.module(&#039;legendDirectives&#039;, [])
        .directive(&#039;simpleSvgLegend&#039;, function () {
            return {
                restrict: &#039;EA&#039;,
                scope: {
                    id: &#039;@&#039;,
                    width: &#039;@&#039;,
                    height: &#039;@&#039;,
                    margin: &#039;@&#039;,
                    x: &#039;@&#039;,
                    y: &#039;@&#039;,
                    labels: &#039;@&#039;,
                    styles: &#039;@&#039;,
                    classes: &#039;@&#039;,
                    shapes: &#039;@&#039;,  //rect, circle, ellipse
                    padding: &#039;@&#039;,
                    columns: &#039;@&#039;
                },
                compile: function () {
                    return function link(scope, element, attrs) {
                        &quot;use strict&quot;;
                        var id,
                            width,
                            height,
                            margin,
                            widthTracker = 0,
                            heightTracker = 0,
                            columns = 1,
                            columnTracker = 0,
                            padding = 10,
                            paddingStr,
                            svgNamespace = &#039;http://www.w3.org/2000/svg&#039;,
                            svg,
                            g,
                            labels,
                            styles,
                            classes,
                            shapes,
                            x = 0,
                            y = 0,
                            container;

                        margin = (scope.$eval(attrs.margin) || { left: 5, top: 5, bottom: 5, right: 5 });
                        width = (attrs.width === &quot;undefined&quot; ? ((element[0].parentElement.offsetWidth) - (margin.left + margin.right)) : (+attrs.width - (margin.left + margin.right)));
                        height = (attrs.height === &quot;undefined&quot; ? ((element[0].parentElement.offsetHeight) - (margin.top + margin.bottom)) : (+attrs.height - (margin.top + margin.bottom)));

                        if (!attrs.id) {
                            //if an id is not supplied, create a random id.
                            id = &#039;legend-&#039; + Math.random();
                        } else {
                            id = attrs.id;
                        }
                        container = d3.select(this).classed(&#039;legend-&#039; + id, true);

                        if (attrs.columns) {
                            columns = (+attrs.columns);
                        }

                        if (attrs.padding) {
                            padding = (+attrs.padding);
                        }
                        paddingStr = padding + &#039;&#039;;

                        svg = document.createElementNS(svgNamespace, &#039;svg&#039;);
                        if (attrs.width) {
                            svg.setAttribute(&#039;width&#039;, width + &#039;&#039;);
                        }

                        if (attrs.height) {
                            svg.setAttribute(&#039;height&#039;, height + &#039;&#039;);
                        }
                        svg.setAttribute(&#039;id&#039;, id);

                        if (attrs.x) {
                            x = (+attrs.x);
                        }

                        if (attrs.y) {
                            y = (+attrs.y);
                        }

                        element.append(svg);

                        g = document.createElementNS(svgNamespace, &#039;g&#039;);
                        g.setAttribute(&#039;transform&#039;, &#039;translate(&#039; + x + &#039;,&#039; + y + &#039;)&#039;);

                        svg.appendChild(g);

                        if (attrs.labels) {
                            labels = scope.$eval(attrs.labels);
                        }

                        if (attrs.styles) {
                            styles = scope.$eval(attrs.styles);
                        }

                        if (attrs.classes) {
                            classes = scope.$eval(attrs.classes);
                        }

                        if (attrs.shapes) {
                            shapes = scope.$eval(attrs.shapes);
                        }

                        for (var i in labels) {

                            var shpe = shapes[i], shape, text, textSize, g1;

                            if ((columnTracker % columns) === 0) {
                                widthTracker = 0;
                                heightTracker = heightTracker + (padding + (padding * 1.5));
                            }
                            g1 = document.createElementNS(svgNamespace, &#039;g&#039;);
                            g1.setAttribute(&#039;transform&#039;, &#039;translate(&#039; + widthTracker + &#039;, &#039; + heightTracker + &#039;)&#039;);

                            if (shpe === &#039;rect&#039;) {
                                shape = document.createElementNS(svgNamespace, &#039;rect&#039;);
                                //x, y, rx, ry
                                shape.setAttribute(&#039;y&#039;, (0 - (padding / 2)) + &#039;&#039;);
                                shape.setAttribute(&#039;width&#039;, paddingStr);
                                shape.setAttribute(&#039;height&#039;, paddingStr);
                            } else if (shpe === &#039;ellipse&#039;) {
                                shape = document.createElementNS(svgNamespace, &#039;ellipse&#039;);
                                shape.setAttribute(&#039;rx&#039;, paddingStr);
                                shape.setAttribute(&#039;ry&#039;, (padding + (padding / 2)) + &#039;&#039;);
                            } else {
                                shape = document.createElementNS(svgNamespace, &#039;circle&#039;);
                                shape.setAttribute(&#039;r&#039;, (padding / 2) + &#039;&#039;);
                            }

                            if (styles &amp;&amp; styles[i]) {
                                shape.setAttribute(&#039;style&#039;, styles[i]);
                            }

                            if (classes &amp;&amp; classes[i]) {
                                shape.setAttribute(&#039;class&#039;, classes[i]);
                            }

                            g1.appendChild(shape);

                            widthTracker = widthTracker + shape.clientWidth + (padding + (padding / 2));

                            text = document.createElementNS(svgNamespace, &#039;text&#039;);
                            text.setAttribute(&#039;transform&#039;, &#039;translate(10, 5)&#039;);
                            text.appendChild(document.createTextNode(labels[i]));

                            g1.appendChild(text);
                            g.appendChild(g1);

                            textSize = text.clientWidth;
                            widthTracker = widthTracker + textSize + (padding + (padding * 0.75));

                            columnTracker++;
                        }
                    };
                }
            };
        });
    function processEvents(chart, scope) {

        if (chart.dispatch) {
            if (chart.dispatch.tooltipShow) {
                chart.dispatch.on(&#039;tooltipShow.directive&#039;, function (event) {
                    scope.$emit(&#039;tooltipShow.directive&#039;, event);
                });
            }

            if (chart.dispatch.tooltipHide) {
                chart.dispatch.on(&#039;tooltipHide.directive&#039;, function (event) {
                    scope.$emit(&#039;tooltipHide.directive&#039;, event);
                });
            }

            if (chart.dispatch.beforeUpdate) {
                chart.dispatch.on(&#039;beforeUpdate.directive&#039;, function (event) {
                    scope.$emit(&#039;beforeUpdate.directive&#039;, event);
                });
            }

            if (chart.dispatch.stateChange) {
                chart.dispatch.on(&#039;stateChange.directive&#039;, function (event) {
                    scope.$emit(&#039;stateChange.directive&#039;, event);
                });
            }

            if (chart.dispatch.changeState) {
                chart.dispatch.on(&#039;changeState.directive&#039;, function (event) {
                    scope.$emit(&#039;changeState.directive&#039;, event);
                });
            }
        }

        if (chart.lines) {
            chart.lines.dispatch.on(&#039;elementMouseover.tooltip.directive&#039;, function (event) {
                scope.$emit(&#039;elementMouseover.tooltip.directive&#039;, event);
            });

            chart.lines.dispatch.on(&#039;elementMouseout.tooltip.directive&#039;, function (event) {
                scope.$emit(&#039;elementMouseout.tooltip.directive&#039;, event);
            });

            chart.lines.dispatch.on(&#039;elementClick.directive&#039;, function (event) {
                scope.$emit(&#039;elementClick.directive&#039;, event);
            });
        }

        if (chart.stacked &amp;&amp; chart.stacked.dispatch) {
            chart.stacked.dispatch.on(&#039;areaClick.toggle.directive&#039;, function (event) {
                scope.$emit(&#039;areaClick.toggle.directive&#039;, event);
            });

            chart.stacked.dispatch.on(&#039;tooltipShow.directive&#039;, function (event) {
                scope.$emit(&#039;tooltipShow.directive&#039;, event);
            });


            chart.stacked.dispatch.on(&#039;tooltipHide.directive&#039;, function (event) {
                scope.$emit(&#039;tooltipHide.directive&#039;, event);
            });

        }

        if (chart.interactiveLayer) {
            if (chart.interactiveLayer.elementMouseout) {
                chart.interactiveLayer.dispatch.on(&#039;elementMouseout.directive&#039;, function (event) {
                    scope.$emit(&#039;elementMouseout.directive&#039;, event);
                });
            }

            if (chart.interactiveLayer.elementMousemove) {
                chart.interactiveLayer.dispatch.on(&#039;elementMousemove.directive&#039;, function (event) {
                    scope.$emit(&#039;elementMousemove.directive&#039;, event);
                });
            }
        }

        if (chart.discretebar) {
            chart.discretebar.dispatch.on(&#039;elementMouseover.tooltip.directive&#039;, function (event) {
                scope.$emit(&#039;elementMouseover.tooltip.directive&#039;, event);
            });

            chart.discretebar.dispatch.on(&#039;elementMouseout.tooltip.directive&#039;, function (event) {
                scope.$emit(&#039;elementMouseover.tooltip.directive&#039;, event);
            });
        }

        if (chart.multibar) {
            chart.multibar.dispatch.on(&#039;elementMouseover.tooltip.directive&#039;, function (event) {
                scope.$emit(&#039;elementMouseover.tooltip.directive&#039;, event);
            });

            chart.multibar.dispatch.on(&#039;elementMouseout.tooltip.directive&#039;, function (event) {
                scope.$emit(&#039;elementMouseover.tooltip.directive&#039;, event);
            });

            chart.multibar.dispatch.on(&#039;elementClick.directive&#039;, function (event) {
                scope.$emit(&#039;elementClick.directive&#039;, event);
            });

        }

        if (chart.pie) {
            chart.pie.dispatch.on(&#039;elementMouseover.tooltip.directive&#039;, function (event) {
                scope.$emit(&#039;elementMouseover.tooltip.directive&#039;, event);
            });

            chart.pie.dispatch.on(&#039;elementMouseout.tooltip.directive&#039;, function (event) {
                scope.$emit(&#039;elementMouseover.tooltip.directive&#039;, event);
            });
        }

        if (chart.scatter) {
            chart.scatter.dispatch.on(&#039;elementMouseover.tooltip.directive&#039;, function (event) {
                scope.$emit(&#039;elementMouseover.tooltip.directive&#039;, event);
            });

            chart.scatter.dispatch.on(&#039;elementMouseout.tooltip.directive&#039;, function (event) {
                scope.$emit(&#039;elementMouseover.tooltip.directive&#039;, event);
            });
        }

        if (chart.bullet) {
            chart.bullet.dispatch.on(&#039;elementMouseover.tooltip.directive&#039;, function (event) {
                scope.$emit(&#039;elementMouseover.tooltip.directive&#039;, event);
            });

            chart.bullet.dispatch.on(&#039;elementMouseout.tooltip.directive&#039;, function (event) {
                scope.$emit(&#039;elementMouseover.tooltip.directive&#039;, event);
            });
        }

        if (chart.legend) {
            //stateChange
            chart.legend.dispatch.on(&#039;stateChange.legend.directive&#039;, function (event) {
                scope.$emit(&#039;stateChange.legend.directive&#039;, event);
            });

            chart.legend.dispatch.on(&#039;legendClick.directive&#039;, function (d, i) {
                scope.$emit(&#039;legendClick.directive&#039;, d, i);
            });

        }

        if (chart.controls) {
            if (chart.controls.legendClick) {
                chart.controls.dispatch.on(&#039;legendClick.directive&#039;, function (d, i) {
                    scope.$emit(&#039;legendClick.directive&#039;, d, i);
                });
            }
        }

    }

    function configureXaxis(chart, scope, attrs) {
        &quot;use strict&quot;;
        if (attrs.xaxisorient) {
            chart.xAxis.orient(attrs.xaxisorient);
        }
        if (attrs.xaxisticks) {
            chart.xAxis.scale().ticks(attrs.xaxisticks);
        }
        if (attrs.xaxistickvalues) {
            if (Array.isArray(scope.$eval(attrs.xaxistickvalues))) {
                chart.xAxis.tickValues(scope.$eval(attrs.xaxistickvalues));
            } else if (typeof scope.xaxistickvalues() === &#039;function&#039;) {
                chart.xAxis.tickValues(scope.xaxistickvalues());
            }
        }
        if (attrs.xaxisticksubdivide) {
            chart.xAxis.tickSubdivide(scope.xaxisticksubdivide());
        }
        if (attrs.xaxisticksize) {
            chart.xAxis.tickSize(scope.xaxisticksize());
        }
        if (attrs.xaxistickpadding) {
            chart.xAxis.tickPadding(scope.xaxistickpadding());
        }
        if (attrs.xaxistickformat) {
            chart.xAxis.tickFormat(scope.xaxistickformat());
        }
        if (attrs.xaxislabel) {
            chart.xAxis.axisLabel(attrs.xaxislabel);
        }
        if (attrs.xaxisscale) {
            chart.xAxis.scale(scope.xaxisscale());
        }
        if (attrs.xaxisdomain) {
            chart.xAxis.domain(scope.xaxisdomain());
        }
        if (attrs.xaxisrange) {
            chart.xAxis.range(scope.xaxisrange());
        }
        if (attrs.xaxisrangeband) {
            chart.xAxis.rangeBand(scope.xaxisrangeband());
        }
        if (attrs.xaxisrangebands) {
            chart.xAxis.rangeBands(scope.xaxisrangebands());
        }
        if (attrs.xaxisshowmaxmin) {
            chart.xAxis.showMaxMin((attrs.xaxisshowmaxmin === &quot;true&quot;));
        }
        if (attrs.xaxishighlightzero) {
            chart.xAxis.highlightZero((attrs.xaxishighlightzero === &quot;true&quot;));
        }
        if (attrs.xaxisrotatelabels) {
            chart.xAxis.rotateLabels((+attrs.xaxisrotatelabels));
        }
        //    if(attrs.xaxisrotateylabel){
        //        chart.xAxis.rotateYLabel((attrs.xaxisrotateylabel === &quot;true&quot;));
        //    }
        if (attrs.xaxisstaggerlabels) {
            chart.xAxis.staggerLabels((attrs.xaxisstaggerlabels === &quot;true&quot;));
        }
    }

    function configureX2axis(chart, scope, attrs) {
        &quot;use strict&quot;;
        if (attrs.x2axisorient) {
            chart.x2Axis.orient(attrs.x2axisorient);
        }
        if (attrs.x2axisticks) {
            chart.x2Axis.scale().ticks(attrs.x2axisticks);
        }
        if (attrs.x2axistickvalues) {
            if (Array.isArray(scope.$eval(attrs.x2axistickvalues))) {
                chart.x2Axis.tickValues(scope.$eval(attrs.x2axistickvalues));
            } else if (typeof scope.xaxistickvalues() === &#039;function&#039;) {
                chart.x2Axis.tickValues(scope.x2axistickvalues());
            }
        }
        if (attrs.x2axisticksubdivide) {
            chart.x2Axis.tickSubdivide(scope.x2axisticksubdivide());
        }
        if (attrs.x2axisticksize) {
            chart.x2Axis.tickSize(scope.x2axisticksize());
        }
        if (attrs.x2axistickpadding) {
            chart.x2Axis.tickPadding(scope.x2axistickpadding());
        }
        if (attrs.x2axistickformat) {
            chart.x2Axis.tickFormat(scope.x2axistickformat());
        }
        if (attrs.x2axislabel) {
            chart.x2Axis.axisLabel(attrs.x2axislabel);
        }
        if (attrs.x2axisscale) {
            chart.x2Axis.scale(scope.x2axisscale());
        }
        if (attrs.x2axisdomain) {
            chart.x2Axis.domain(scope.x2axisdomain());
        }
        if (attrs.x2axisrange) {
            chart.x2Axis.range(scope.x2axisrange());
        }
        if (attrs.x2axisrangeband) {
            chart.x2Axis.rangeBand(scope.x2axisrangeband());
        }
        if (attrs.x2axisrangebands) {
            chart.x2Axis.rangeBands(scope.x2axisrangebands());
        }
        if (attrs.x2axisshowmaxmin) {
            chart.x2Axis.showMaxMin((attrs.x2axisshowmaxmin === &quot;true&quot;));
        }
        if (attrs.x2axishighlightzero) {
            chart.x2Axis.highlightZero((attrs.x2axishighlightzero === &quot;true&quot;));
        }
        if (attrs.x2axisrotatelables) {
            chart.x2Axis.rotateLabels((+attrs.x2axisrotatelables));
        }
        //    if(attrs.xaxisrotateylabel){
        //        chart.xAxis.rotateYLabel((attrs.xaxisrotateylabel === &quot;true&quot;));
        //    }
        if (attrs.x2axisstaggerlabels) {
            chart.x2Axis.staggerLabels((attrs.x2axisstaggerlabels === &quot;true&quot;));
        }
    }

    function configureYaxis(chart, scope, attrs) {
        &quot;use strict&quot;;
        if (attrs.yaxisorient) {
            chart.yAxis.orient(attrs.yaxisorient);
        }
        if (attrs.yaxisticks) {
            chart.yAxis.scale().ticks(attrs.yaxisticks);
        }
        if (attrs.yaxistickvalues) {
            if (Array.isArray(scope.$eval(attrs.yaxistickvalues))) {
                chart.yAxis.tickValues(scope.$eval(attrs.yaxistickvalues));
            } else if (typeof scope.yaxistickvalues() === &#039;function&#039;) {
                chart.yAxis.tickValues(scope.yaxistickvalues());
            }
        }
        if (attrs.yaxisticksubdivide) {
            chart.yAxis.tickSubdivide(scope.yaxisticksubdivide());
        }
        if (attrs.yaxisticksize) {
            chart.yAxis.tickSize(scope.yaxisticksize());
        }
        if (attrs.yaxistickpadding) {
            chart.yAxis.tickPadding(scope.yaxistickpadding());
        }
        if (attrs.yaxistickformat) {
            chart.yAxis.tickFormat(scope.yaxistickformat());
        }
        if (attrs.yaxislabel) {
            chart.yAxis.axisLabel(attrs.yaxislabel);
        }
        if (attrs.yaxisscale) {
            chart.yAxis.scale(scope.yaxisscale());
        }
        if (attrs.yaxisdomain) {
            chart.yAxis.domain(scope.yaxisdomain());
        }
        if (attrs.yaxisrange) {
            chart.yAxis.range(scope.yaxisrange());
        }
        if (attrs.yaxisrangeband) {
            chart.yAxis.rangeBand(scope.yaxisrangeband());
        }
        if (attrs.yaxisrangebands) {
            chart.yAxis.rangeBands(scope.yaxisrangebands());
        }
        if (attrs.yaxisshowmaxmin) {
            chart.yAxis.showMaxMin((attrs.yaxisshowmaxmin === &quot;true&quot;));
        }
        if (attrs.yaxishighlightzero) {
            chart.yAxis.highlightZero((attrs.yaxishighlightzero === &quot;true&quot;));
        }
        if (attrs.yaxisrotatelabels) {
            chart.yAxis.rotateLabels(attrs.yaxisrotatelabels);
        }
        if (attrs.yaxisrotateylabel) {
            chart.yAxis.rotateYLabel((attrs.yaxisrotateylabel === &quot;true&quot;));
        }
        if (attrs.yaxisstaggerlabels) {
            chart.yAxis.staggerLabels((attrs.yaxisstaggerlabels === &quot;true&quot;));
        }
    }


    function configureY1axis(chart, scope, attrs) {
        &quot;use strict&quot;;
        if (attrs.y1axisticks) {
            chart.y1Axis.scale().ticks(attrs.y1axisticks);
        }
        if (attrs.y1axistickvalues) {
            chart.y1Axis.tickValues(attrs.y1axistickvalues);
        }
        if (attrs.y1axisticksubdivide) {
            chart.y1Axis.tickSubdivide(scope.y1axisticksubdivide());
        }
        if (attrs.y1axisticksize) {
            chart.y1Axis.tickSize(scope.y1axisticksize());
        }
        if (attrs.y1axistickpadding) {
            chart.y1Axis.tickPadding(scope.y1axistickpadding());
        }
        if (attrs.y1axistickformat) {
            chart.y1Axis.tickFormat(scope.y1axistickformat());
        }
        if (attrs.y1axislabel) {
            chart.y1Axis.axisLabel(attrs.y1axislabel);
        }
        if (attrs.y1axisscale) {
            chart.y1Axis.yScale(scope.y1axisscale());
        }
        if (attrs.y1axisdomain) {
            chart.y1Axis.domain(scope.y1axisdomain());
        }
        if (attrs.y1axisrange) {
            chart.y1Axis.range(scope.y1axisrange());
        }
        if (attrs.y1axisrangeband) {
            chart.y1Axis.rangeBand(scope.y1axisrangeband());
        }
        if (attrs.y1axisrangebands) {
            chart.y1Axis.rangeBands(scope.y1axisrangebands());
        }
        if (attrs.y1axisshowmaxmin) {
            chart.y1Axis.showMaxMin((attrs.y1axisshowmaxmin === &quot;true&quot;));
        }
        if (attrs.y1axishighlightzero) {
            chart.y1Axis.highlightZero((attrs.y1axishighlightzero === &quot;true&quot;));
        }
        if (attrs.y1axisrotatelabels) {
            chart.y1Axis.rotateLabels(scope.y1axisrotatelabels);
        }
        if (attrs.y1axisrotateylabel) {
            chart.y1Axis.rotateYLabel((attrs.y1axisrotateylabel === &quot;true&quot;));
        }
        if (attrs.y1axisstaggerlabels) {
            chart.y1Axis.staggerlabels((attrs.y1axisstaggerlabels === &quot;true&quot;));
        }
    }


    function configureY2axis(chart, scope, attrs) {
        &quot;use strict&quot;;
        if (attrs.y2axisticks) {
            chart.y2Axis.scale().ticks(attrs.y2axisticks);
        }
        if (attrs.y2axistickvalues) {
            chart.y2Axis.tickValues(scope.$eval(attrs.y2axistickvalues));
        }
        if (attrs.y2axisticksubdivide) {
            chart.y2Axis.tickSubdivide(scope.y2axisticksubdivide());
        }
        if (attrs.y2axisticksize) {
            chart.y2Axis.tickSize(scope.y2axisticksize());
        }
        if (attrs.y2axistickpadding) {
            chart.y2Axis.tickPadding(scope.y2axistickpadding());
        }
        if (attrs.y2axistickformat) {
            chart.y2Axis.tickFormat(scope.y2axistickformat());
        }
        if (attrs.y2axislabel) {
            chart.y2Axis.axisLabel(attrs.y2axislabel);
        }
        if (attrs.y2axisscale) {
            chart.y2Axis.yScale(scope.y2axisscale());
        }
        if (attrs.y2axisdomain) {
            chart.y2Axis.domain(scope.y2axisdomain());
        }
        if (attrs.y2axisrange) {
            chart.y2Axis.range(scope.y2axisrange());
        }
        if (attrs.y2axisrangeband) {
            chart.y2Axis.rangeBand(scope.y2axisrangeband());
        }
        if (attrs.y2axisrangebands) {
            chart.y2Axis.rangeBands(scope.y2axisrangebands());
        }
        if (attrs.y2axisshowmaxmin) {
            chart.y2Axis.showMaxMin((attrs.y2axisshowmaxmin === &quot;true&quot;));
        }
        if (attrs.y2axishighlightzero) {
            chart.y2Axis.highlightZero((attrs.y2axishighlightzero === &quot;true&quot;));
        }
        if (attrs.y2axisrotatelabels) {
            chart.y2Axis.rotateLabels(scope.y2axisrotatelabels);
        }
        if (attrs.y2axisrotateylabel) {
            chart.y2Axis.rotateYLabel((attrs.y2axisrotateylabel === &quot;true&quot;));
        }
        if (attrs.y2axisstaggerlabels) {
            chart.y2Axis.staggerlabels((attrs.y2axisstaggerlabels === &quot;true&quot;));
        }
    }
    function initializeMargin(scope, attrs) {
        &#039;use strict&#039;;
        var margin = (scope.$eval(attrs.margin) || { left: 50, top: 50, bottom: 50, right: 50 });
        if (typeof (margin) !== &quot;object&quot;) {
            // we were passed a vanilla int, convert to full margin object
            margin = { left: margin, top: margin, bottom: margin, right: margin };
        }
        scope.margin = margin;
    }

    function initializeWidth(scope, attrs, element) {
        &#039;use strict&#039;;
        var marginAdjustment = 0;
        if (attrs.width === &quot;undefined&quot;) {
            scope.width = element[0].parentElement.offsetWidth;
        } else {
            scope.width = (+attrs.width);
        }
        if (!scope.margin.left || !scope.margin.right) {
            initializeMargin(scope, attrs, element);
        }
        marginAdjustment = (scope.margin.left + scope.margin.right);
        scope.width = (((scope.width - marginAdjustment) &gt; 0) ? (scope.width - marginAdjustment) : 0);
    }

    function initializeHeight(scope, attrs, element) {
        &#039;use strict&#039;;
        var marginAdjustment = 0;
        if (attrs.height === &quot;undefined&quot;) {
            scope.height = element[0].parentElement.offsetHeight;
        } else {
            scope.height = (+attrs.height);
        }
        if (!scope.margin.top || !scope.margin.bottom) {
            initializeMargin(scope, attrs, element);
        }
        marginAdjustment = (scope.margin.top + scope.margin.bottom);
        scope.height = (((scope.height - marginAdjustment) &gt; 0) ? (scope.height - marginAdjustment) : 0);
    }

    function setupDimensions(scope, attrs, element) {
        &#039;use strict&#039;;
        initializeWidth(scope, attrs, element);
        initializeHeight(scope, attrs, element);
    }

    function checkElementID(scope, attrs, element, chart, data) {
        &#039;use strict&#039;;
        var dataAttributeChartID; //randomly generated if id attribute doesn&#039;t exist
        if (!attrs.id) {
            dataAttributeChartID = &quot;chartid&quot; + Math.floor(Math.random() * 1000000001);
            angular.element(element).attr(&#039;data-chartid&#039;, dataAttributeChartID);
            //if an id is not supplied, create a random id.
            if (d3.select(&#039;[data-chartid=&#039; + dataAttributeChartID + &#039;] svg&#039;).empty()) {
                d3.select(&#039;[data-chartid=&#039; + dataAttributeChartID + &#039;]&#039;).append(&#039;svg&#039;)
                .attr(&#039;height&#039;, scope.height)
                .attr(&#039;width&#039;, scope.width)
                .datum(data)
                .transition().duration((attrs.transitionduration === undefined ? 250 : (+attrs.transitionduration)))
                .call(chart);
            } else {
                d3.select(&#039;[data-chartid=&#039; + dataAttributeChartID + &#039;] svg&#039;)
                .attr(&#039;height&#039;, scope.height)
                .attr(&#039;width&#039;, scope.width)
                .datum(data)
                .transition().duration((attrs.transitionduration === undefined ? 250 : (+attrs.transitionduration)))
                .call(chart);
            }
        } else {
            if (d3.select(&#039;#&#039; + attrs.id + &#039; svg&#039;).empty()) {
                d3.select(&#039;#&#039; + attrs.id)
                    .append(&#039;svg&#039;);
            }
            d3.select(&#039;#&#039; + attrs.id + &#039; svg&#039;)
                .attr(&#039;height&#039;, scope.height)
                .attr(&#039;width&#039;, scope.width)
                .datum(data)
                .transition().duration((attrs.transitionduration === undefined ? 250 : (+attrs.transitionduration)))
                .call(chart);
        }
    }

    angular.module(&#039;nvd3ChartDirectives&#039;, [])
        .directive(&#039;nvd3LineChart&#039;, [function () {
            &#039;use strict&#039;;
            return {
                restrict: &#039;EA&#039;,
                scope: {
                    data: &#039;=&#039;,
                    width: &#039;@&#039;,
                    height: &#039;@&#039;,
                    id: &#039;@&#039;,
                    showlegend: &#039;@&#039;,
                    tooltips: &#039;@&#039;,
                    showxaxis: &#039;@&#039;,
                    showyaxis: &#039;@&#039;,
                    rightalignyaxis: &#039;@&#039;,
                    defaultstate: &#039;@&#039;,
                    nodata: &#039;@&#039;,
                    margin: &#039;&amp;&#039;,
                    tooltipcontent: &#039;&amp;&#039;,
                    color: &#039;&amp;&#039;,
                    x: &#039;&amp;&#039;,
                    y: &#039;&amp;&#039;,
                    forcex: &#039;@&#039;,
                    forcey: &#039;@&#039;,
                    isArea: &#039;@&#039;,
                    interactive: &#039;@&#039;,
                    clipedge: &#039;@&#039;,
                    clipvoronoi: &#039;@&#039;,
                    interpolate: &#039;@&#039;,

                    //xaxis
                    xaxisorient: &#039;&amp;&#039;,
                    xaxisticks: &#039;@&#039;,
                    xaxistickvalues: &#039;&amp;xaxistickvalues&#039;,
                    xaxisticksubdivide: &#039;&amp;&#039;,
                    xaxisticksize: &#039;&amp;&#039;,
                    xaxistickpadding: &#039;&amp;&#039;,
                    xaxistickformat: &#039;&amp;&#039;,
                    xaxislabel: &#039;@&#039;,
                    xaxisscale: &#039;&amp;&#039;,
                    xaxisdomain: &#039;&amp;&#039;,
                    xaxisrange: &#039;&amp;&#039;,
                    xaxisrangeband: &#039;&amp;&#039;,
                    xaxisrangebands: &#039;&amp;&#039;,
                    xaxisshowmaxmin: &#039;@&#039;,
                    xaxishighlightzero: &#039;@&#039;,
                    xaxisrotatelabels: &#039;@&#039;,
                    xaxisrotateylabel: &#039;@&#039;,
                    xaxisstaggerlabels: &#039;@&#039;,

                    //yaxis
                    yaxisorient: &#039;&amp;&#039;,
                    yaxisticks: &#039;&amp;&#039;,
                    yaxistickvalues: &#039;&amp;yaxistickvalues&#039;,
                    yaxisticksubdivide: &#039;&amp;&#039;,
                    yaxisticksize: &#039;&amp;&#039;,
                    yaxistickpadding: &#039;&amp;&#039;,
                    yaxistickformat: &#039;&amp;&#039;,
                    yaxislabel: &#039;@&#039;,
                    yaxisscale: &#039;&amp;&#039;,
                    yaxisdomain: &#039;&amp;&#039;,
                    yaxisrange: &#039;&amp;&#039;,
                    yaxisrangeband: &#039;&amp;&#039;,
                    yaxisrangebands: &#039;&amp;&#039;,
                    yaxisshowmaxmin: &#039;@&#039;,
                    yaxishighlightzero: &#039;@&#039;,
                    yaxisrotatelabels: &#039;@&#039;,
                    yaxisrotateylabel: &#039;@&#039;,
                    yaxisstaggerlabels: &#039;@&#039;,

                    //angularjs specific
                    objectequality: &#039;@&#039;,  //$watch(watchExpression, listener, objectEquality)

                    //d3.js specific
                    transitionduration: &#039;@&#039;

                },
                controller: [&#039;$scope&#039;, &#039;$element&#039;, &#039;$attrs&#039;, function ($scope, $element, $attrs) {
                    $scope.d3Call = function (data, chart) {
                        checkElementID($scope, $attrs, $element, chart, data);
                    };
                }],
                link: function (scope, element, attrs) {
                    scope.$watch(&#039;data&#039;, function (data) {
                        if (data) {
                            //if the chart exists on the scope, do not call addGraph again, update data and call the chart.
                            if (scope.chart) {
                                return scope.d3Call(data, scope.chart);
                            }
                            nv.addGraph({
                                generate: function () {
                                    setupDimensions(scope, attrs, element);
                                    var chart = nv.models.lineChart()
                                        .width(scope.width)
                                        .height(scope.height)
                                        .margin(scope.margin)
                                        .x(attrs.x === undefined ? function (d) { return d[0]; } : scope.x())
                                        .y(attrs.y === undefined ? function (d) { return d[1]; } : scope.y())
                                        .forceX(attrs.forcex === undefined ? [] : scope.$eval(attrs.forcex)) // List of numbers to Force into the X scale (ie. 0, or a max / min, etc.)
                                        .forceY(attrs.forcey === undefined ? [0] : scope.$eval(attrs.forcey)) // List of numbers to Force into the Y scale
                                        .showLegend(attrs.showlegend === undefined ? false : (attrs.showlegend === &quot;true&quot;))
                                        .tooltips(attrs.tooltips === undefined ? false : (attrs.tooltips === &quot;true&quot;))
                                        .showXAxis(attrs.showxaxis === undefined ? false : (attrs.showxaxis === &quot;true&quot;))
                                        .showYAxis(attrs.showyaxis === undefined ? false : (attrs.showyaxis === &quot;true&quot;))
                                        .rightAlignYAxis(attrs.rightalignyaxis === undefined ? false : (attrs.rightalignyaxis === &quot;true&quot;))
                                        .noData(attrs.nodata === undefined ? &#039;No Data Available.&#039; : scope.nodata)
                                        .interactive(attrs.interactive === undefined ? false : (attrs.interactive === &quot;true&quot;))
                                        .clipEdge(attrs.clipedge === undefined ? false : (attrs.clipedge === &quot;true&quot;))
                                        .clipVoronoi(attrs.clipvoronoi === undefined ? false : (attrs.clipvoronoi === &quot;true&quot;))
                                        .interpolate(attrs.interpolate === undefined ? &#039;linear&#039; : attrs.interpolate)
                                        .color(attrs.color === undefined ? nv.utils.defaultColor() : scope.color())
                                        .isArea(attrs.isarea === undefined ? function () { return false; } : function () { return (attrs.isarea === &quot;true&quot;); });

                                    if (chart.useInteractiveGuideline) {
                                        chart.useInteractiveGuideline(attrs.useinteractiveguideline === undefined ? false : (attrs.useinteractiveguideline === &quot;true&quot;));
                                    }

                                    if (attrs.tooltipcontent) {
                                        chart.tooltipContent(scope.tooltipcontent());
                                    }

                                    configureXaxis(chart, scope, attrs);
                                    configureYaxis(chart, scope, attrs);
                                    processEvents(chart, scope);
                                    scope.d3Call(data, chart);
                                    nv.utils.windowResize(chart.update);
                                    scope.chart = chart;
                                    return chart;
                                }
                            });
                        }
                    }, (attrs.objectequality === undefined ? false : (attrs.objectequality === &quot;true&quot;)));
                    
                    element.$on(&#039;$destroy&#039;, function() {
                        console.log(&#039;NVD3: hulk, distruggeeeee!!&#039;);
                        scope.$destroy();
                    });
                }
            };
        }])
        .directive(&#039;nvd3CumulativeLineChart&#039;, [function () {
            &#039;use strict&#039;;
            return {
                restrict: &#039;EA&#039;,
                scope: {
                    data: &#039;=&#039;,
                    width: &#039;@&#039;,
                    height: &#039;@&#039;,
                    id: &#039;@&#039;,
                    showlegend: &#039;@&#039;,
                    tooltips: &#039;@&#039;,
                    showxaxis: &#039;@&#039;,
                    showyaxis: &#039;@&#039;,
                    rightalignyaxis: &#039;@&#039;,
                    defaultstate: &#039;@&#039;,
                    nodata: &#039;@&#039;,
                    margin: &#039;&amp;&#039;,
                    tooltipcontent: &#039;&amp;&#039;,
                    color: &#039;&amp;&#039;,
                    x: &#039;&amp;&#039;,
                    y: &#039;&amp;&#039;,
                    forcex: &#039;@&#039;,
                    forcey: &#039;@&#039;,
                    isArea: &#039;@&#039;,
                    interactive: &#039;@&#039;,
                    clipedge: &#039;@&#039;,
                    clipvoronoi: &#039;@&#039;,
                    usevoronoi: &#039;@&#039;,
                    average: &#039;&amp;&#039;,
                    rescaley: &#039;@&#039;,

                    //xaxis
                    xaxisorient: &#039;&amp;&#039;,
                    xaxisticks: &#039;&amp;&#039;,
                    xaxistickvalues: &#039;&amp;xaxistickvalues&#039;,
                    xaxisticksubdivide: &#039;&amp;&#039;,
                    xaxisticksize: &#039;&amp;&#039;,
                    xaxistickpadding: &#039;&amp;&#039;,
                    xaxistickformat: &#039;&amp;&#039;,
                    xaxislabel: &#039;@&#039;,
                    xaxisscale: &#039;&amp;&#039;,
                    xaxisdomain: &#039;&amp;&#039;,
                    xaxisrange: &#039;&amp;&#039;,
                    xaxisrangeband: &#039;&amp;&#039;,
                    xaxisrangebands: &#039;&amp;&#039;,
                    xaxisshowmaxmin: &#039;@&#039;,
                    xaxishighlightzero: &#039;@&#039;,
                    xaxisrotatelabels: &#039;@&#039;,
                    xaxisrotateylabel: &#039;@&#039;,
                    xaxisstaggerlabels: &#039;@&#039;,

                    //yaxis
                    yaxisorient: &#039;&amp;&#039;,
                    yaxisticks: &#039;&amp;&#039;,
                    yaxistickvalues: &#039;&amp;yaxistickvalues&#039;,
                    yaxisticksubdivide: &#039;&amp;&#039;,
                    yaxisticksize: &#039;&amp;&#039;,
                    yaxistickpadding: &#039;&amp;&#039;,
                    yaxistickformat: &#039;&amp;&#039;,
                    yaxislabel: &#039;@&#039;,
                    yaxisscale: &#039;&amp;&#039;,
                    yaxisdomain: &#039;&amp;&#039;,
                    yaxisrange: &#039;&amp;&#039;,
                    yaxisrangeband: &#039;&amp;&#039;,
                    yaxisrangebands: &#039;&amp;&#039;,
                    yaxisshowmaxmin: &#039;@&#039;,
                    yaxishighlightzero: &#039;@&#039;,
                    yaxisrotatelabels: &#039;@&#039;,
                    yaxisrotateylabel: &#039;@&#039;,
                    yaxisstaggerlabels: &#039;@&#039;,

                    //angularjs specific
                    objectequality: &#039;@&#039;,  //$watch(watchExpression, listener, objectEquality)

                    //d3.js specific
                    transitionduration: &#039;@&#039;

                },
                controller: [&#039;$scope&#039;, &#039;$element&#039;, &#039;$attrs&#039;, function ($scope, $element, $attrs) {
                    $scope.d3Call = function (data, chart) {
                        checkElementID($scope, $attrs, $element, chart, data);
                    };
                }],
                link: function (scope, element, attrs) {
                    scope.$watch(&#039;data&#039;, function (data) {
                        if (data) {
                            //if the chart exists on the scope, do not call addGraph again, update data and call the chart.
                            if (scope.chart) {
                                return scope.d3Call(data, scope.chart);
                            }
                            nv.addGraph({
                                generate: function () {
                                    setupDimensions(scope, attrs, element);
                                    var chart = nv.models.cumulativeLineChart()
                                        .width(scope.width)
                                        .height(scope.height)
                                        .margin(scope.margin)
                                        .x(attrs.x === undefined ? function (d) { return d[0]; } : scope.x())
                                        .y(attrs.y === undefined ? function (d) { return d[1]; } : scope.y())
                                        .forceX(attrs.forcex === undefined ? [] : scope.$eval(attrs.forcex)) // List of numbers to Force into the X scale (ie. 0, or a max / min, etc.)
                                        .forceY(attrs.forcey === undefined ? [0] : scope.$eval(attrs.forcey)) // List of numbers to Force into the Y scale
                                        .showLegend(attrs.showlegend === undefined ? false : (attrs.showlegend === &quot;true&quot;))
                                        .tooltips(attrs.tooltips === undefined ? false : (attrs.tooltips === &quot;true&quot;))
                                        .showXAxis(attrs.showxaxis === undefined ? false : (attrs.showxaxis === &quot;true&quot;))
                                        .showYAxis(attrs.showyaxis === undefined ? false : (attrs.showyaxis === &quot;true&quot;))
                                        .rightAlignYAxis(attrs.rightalignyaxis === undefined ? false : (attrs.rightalignyaxis === &quot;true&quot;))
                                        .noData(attrs.nodata === undefined ? &#039;No Data Available.&#039; : scope.nodata)
                                        .interactive(attrs.interactive === undefined ? false : (attrs.interactive === &quot;true&quot;))
                                        .clipEdge(attrs.clipedge === undefined ? false : (attrs.clipedge === &quot;true&quot;))
                                        .clipVoronoi(attrs.clipvoronoi === undefined ? false : (attrs.clipvoronoi === &quot;true&quot;))
                                        .useVoronoi(attrs.usevoronoi === undefined ? false : (attrs.usevoronoi === &quot;true&quot;))
                                        .average(attrs.average === undefined ? function (d) { return d.average; } : scope.average())
                                        .color(attrs.color === undefined ? d3.scale.category10().range() : scope.color())
                                        .isArea(attrs.isarea === undefined ? false : (attrs.isarea === &quot;true&quot;));
                                    //.rescaleY(attrs.rescaley === undefined ? false : (attrs.rescaley === &quot;true&quot;));

                                    if (chart.useInteractiveGuideline) {
                                        chart.useInteractiveGuideline(attrs.useinteractiveguideline === undefined ? false : (attrs.useinteractiveguideline === &quot;true&quot;));
                                    }

                                    if (attrs.tooltipcontent) {
                                        chart.tooltipContent(scope.tooltipcontent());
                                    }

                                    configureXaxis(chart, scope, attrs);
                                    configureYaxis(chart, scope, attrs);
                                    processEvents(chart, scope);
                                    scope.d3Call(data, chart);
                                    nv.utils.windowResize(chart.update);
                                    scope.chart = chart;
                                    return chart;
                                }
                            });
                        }
                    }, (attrs.objectequality === undefined ? false : (attrs.objectequality === &quot;true&quot;)));
                }
            };
        }])
        .directive(&#039;nvd3StackedAreaChart&#039;, [function () {
            return {
                restrict: &#039;EA&#039;,
                scope: {
                    data: &#039;=&#039;,
                    width: &#039;@&#039;,
                    height: &#039;@&#039;,
                    id: &#039;@&#039;,
                    showlegend: &#039;@&#039;,
                    tooltips: &#039;@&#039;,
                    showcontrols: &#039;@&#039;,
                    nodata: &#039;@&#039;,
                    margin: &#039;&amp;&#039;,
                    tooltipcontent: &#039;&amp;&#039;,
                    color: &#039;&amp;&#039;,
                    x: &#039;&amp;&#039;,
                    y: &#039;&amp;&#039;,
                    forcex: &#039;@&#039;, //List of numbers to Force into the X scale (ie. 0, or a max / min, etc.)
                    forcey: &#039;@&#039;, // List of numbers to Force into the Y scale
                    forcesize: &#039;@&#039;, // List of numbers to Force into the Size scale

                    interactive: &#039;@&#039;,
                    usevoronoi: &#039;@&#039;,
                    clipedge: &#039;@&#039;,
                    interpolate: &#039;@&#039;,
                    style: &#039;@&#039;,     //stack, stream, stream-center, expand
                    order: &#039;@&#039;,     //default, inside-out
                    offset: &#039;@&#039;,    //zero, wiggle, silhouette, expand
                    size: &#039;&amp;&#039;,      //accessor to get the point size
                    xScale: &#039;&amp;&#039;,
                    yScale: &#039;&amp;&#039;,
                    xDomain: &#039;&amp;&#039;,
                    yDomain: &#039;&amp;&#039;,
                    xRange: &#039;&amp;&#039;,
                    yRange: &#039;&amp;&#039;,
                    sizeDomain: &#039;&amp;&#039;,

                    //xaxis
                    xaxisorient: &#039;&amp;&#039;,
                    xaxisticks: &#039;&amp;&#039;,
                    xaxistickvalues: &#039;&amp;xaxistickvalues&#039;,
                    xaxisticksubdivide: &#039;&amp;&#039;,
                    xaxisticksize: &#039;&amp;&#039;,
                    xaxistickpadding: &#039;&amp;&#039;,
                    xaxistickformat: &#039;&amp;&#039;,
                    xaxislabel: &#039;@&#039;,
                    xaxisscale: &#039;&amp;&#039;,
                    xaxisdomain: &#039;&amp;&#039;,
                    xaxisrange: &#039;&amp;&#039;,
                    xaxisrangeband: &#039;&amp;&#039;,
                    xaxisrangebands: &#039;&amp;&#039;,
                    xaxisshowmaxmin: &#039;@&#039;,
                    xaxishighlightzero: &#039;@&#039;,
                    xaxisrotatelabels: &#039;@&#039;,
                    xaxisrotateylabel: &#039;@&#039;,
                    xaxisstaggerlabels: &#039;@&#039;,

                    //yaxis
                    yaxisorient: &#039;&amp;&#039;,
                    yaxisticks: &#039;&amp;&#039;,
                    yaxistickvalues: &#039;&amp;yaxistickvalues&#039;,
                    yaxisticksubdivide: &#039;&amp;&#039;,
                    yaxisticksize: &#039;&amp;&#039;,
                    yaxistickpadding: &#039;&amp;&#039;,
                    yaxistickformat: &#039;&amp;&#039;,
                    yaxislabel: &#039;@&#039;,
                    yaxisscale: &#039;&amp;&#039;,
                    yaxisdomain: &#039;&amp;&#039;,
                    yaxisrange: &#039;&amp;&#039;,
                    yaxisrangeband: &#039;&amp;&#039;,
                    yaxisrangebands: &#039;&amp;&#039;,
                    yaxisshowmaxmin: &#039;@&#039;,
                    yaxishighlightzero: &#039;@&#039;,
                    yaxisrotatelabels: &#039;@&#039;,
                    yaxisrotateylabel: &#039;@&#039;,
                    yaxisstaggerlabels: &#039;@&#039;,

                    //angularjs specific
                    objectequality: &#039;@&#039;,

                    //d3.js specific
                    transitionduration: &#039;@&#039;

                },
                controller: [&#039;$scope&#039;, &#039;$element&#039;, &#039;$attrs&#039;, function ($scope, $element, $attrs) {
                    $scope.d3Call = function (data, chart) {
                        checkElementID($scope, $attrs, $element, chart, data);
                    };
                }],
                link: function (scope, element, attrs) {
                    scope.$watch(&#039;data&#039;, function (data) {
                        if (data) {
                            //if the chart exists on the scope, do not call addGraph again, update data and call the chart.
                            if (scope.chart) {
                                return scope.d3Call(data, scope.chart);
                            }
                            nv.addGraph({
                                generate: function () {
                                    setupDimensions(scope, attrs, element);
                                    var chart = nv.models.stackedAreaChart()
                                        .width(scope.width)
                                        .height(scope.height)
                                        .margin(scope.margin)
                                        .x(attrs.x === undefined ? function (d) { return d[0]; } : scope.x())
                                        .y(attrs.y === undefined ? function (d) { return d[1]; } : scope.y())
                                        .forceX(attrs.forcex === undefined ? [] : scope.$eval(attrs.forcex)) // List of numbers to Force into the X scale (ie. 0, or a max / min, etc.)
                                        .forceY(attrs.forcey === undefined ? [0] : scope.$eval(attrs.forcey)) // List of numbers to Force into the Y scale
                                        .size(attrs.size === undefined ? function (d) { return d.size || 1; } : scope.size())
                                        .forceSize(attrs.forcesize === undefined ? [] : scope.$eval(attrs.forcesize)) // List of numbers to Force into the Size scale
                                        .showLegend(attrs.showlegend === undefined ? false : (attrs.showlegend === &quot;true&quot;))
                                        .showControls(attrs.showcontrols === undefined ? false : (attrs.showcontrols === &quot;true&quot;))
                                        .tooltips(attrs.tooltips === undefined ? false : (attrs.tooltips === &quot;true&quot;))
                                        .noData(attrs.nodata === undefined ? &#039;No Data Available.&#039; : scope.nodata)
                                        .interactive(attrs.interactive === undefined ? false : (attrs.interactive === &quot;true&quot;))
                                        .clipEdge(attrs.clipedge === undefined ? false : (attrs.clipedge === &quot;true&quot;))
                                        .color(attrs.color === undefined ? nv.utils.defaultColor() : scope.color());

                                    if (chart.useInteractiveGuideline) {
                                        chart.useInteractiveGuideline(attrs.useinteractiveguideline === undefined ? false : (attrs.useinteractiveguideline === &quot;true&quot;));
                                    }

                                    if (attrs.usevoronoi) {
                                        chart.useVoronoi((attrs.usevoronoi === &quot;true&quot;));
                                    }

                                    if (attrs.style) {
                                        chart.style(attrs.style);
                                    }

                                    if (attrs.order) {
                                        chart.order(attrs.order);
                                    }

                                    if (attrs.offset) {
                                        chart.offset(attrs.offset);
                                    }

                                    if (attrs.interpolate) {
                                        chart.interpolate(attrs.interpolate);
                                    }

                                    if (attrs.tooltipcontent) {
                                        chart.tooltipContent(scope.tooltipcontent());
                                    }

                                    if (attrs.xscale) {
                                        chart.xScale(scope.xscale());
                                    }

                                    if (attrs.yscale) {
                                        chart.yScale(scope.yscale());
                                    }

                                    if (attrs.xdomain) {
                                        chart.xDomain(scope.xdomain());
                                    }

                                    if (attrs.ydomain) {
                                        chart.yDomain(scope.ydomain());
                                    }

                                    if (attrs.sizedomain) {
                                        chart.sizeDomain(scope.sizedomain());
                                    }

                                    configureXaxis(chart, scope, attrs);
                                    configureYaxis(chart, scope, attrs);
                                    processEvents(chart, scope);
                                    scope.d3Call(data, chart);
                                    nv.utils.windowResize(chart.update);
                                    scope.chart = chart;
                                    return chart;
                                }
                            });
                        }
                    }, (attrs.objectequality === undefined ? false : (attrs.objectequality === &quot;true&quot;)));
                }
            };
        }])
        .directive(&#039;nvd3MultiBarChart&#039;, [function () {
            return {
                restrict: &#039;EA&#039;,
                scope: {
                    data: &#039;=&#039;,
                    width: &#039;@&#039;,
                    height: &#039;@&#039;,
                    id: &#039;@&#039;,
                    showlegend: &#039;@&#039;,
                    tooltips: &#039;@&#039;,
                    tooltipcontent: &#039;&amp;&#039;,
                    color: &#039;&amp;&#039;,
                    showcontrols: &#039;@&#039;,
                    nodata: &#039;@&#039;,
                    reducexticks: &#039;@&#039;,
                    staggerlabels: &#039;@&#039;,
                    rotatelabels: &#039;@&#039;,
                    margin: &#039;&amp;&#039;,
                    x: &#039;&amp;&#039;,
                    y: &#039;&amp;&#039;,
                    //forcex is not exposed in the nvd3 multibar.js file.  it is not here on purpose.
                    forcey: &#039;@&#039;,
                    delay: &#039;@&#039;,
                    stacked: &#039;@&#039;,

                    //xaxis
                    xaxisorient: &#039;&amp;&#039;,
                    xaxisticks: &#039;&amp;&#039;,
                    xaxistickvalues: &#039;&amp;xaxistickvalues&#039;,
                    xaxisticksubdivide: &#039;&amp;&#039;,
                    xaxisticksize: &#039;&amp;&#039;,
                    xaxistickpadding: &#039;&amp;&#039;,
                    xaxistickformat: &#039;&amp;&#039;,
                    xaxislabel: &#039;@&#039;,
                    xaxisscale: &#039;&amp;&#039;,
                    xaxisdomain: &#039;&amp;&#039;,
                    xaxisrange: &#039;&amp;&#039;,
                    xaxisrangeband: &#039;&amp;&#039;,
                    xaxisrangebands: &#039;&amp;&#039;,
                    xaxisshowmaxmin: &#039;@&#039;,
                    xaxishighlightzero: &#039;@&#039;,
                    xaxisrotatelabels: &#039;@&#039;,
                    xaxisrotateylabel: &#039;@&#039;,
                    xaxisstaggerlabels: &#039;@&#039;,

                    //yaxis
                    yaxisorient: &#039;&amp;&#039;,
                    yaxisticks: &#039;&amp;&#039;,
                    yaxistickvalues: &#039;&amp;yaxistickvalues&#039;,
                    yaxisticksubdivide: &#039;&amp;&#039;,
                    yaxisticksize: &#039;&amp;&#039;,
                    yaxistickpadding: &#039;&amp;&#039;,
                    yaxistickformat: &#039;&amp;&#039;,
                    yaxislabel: &#039;@&#039;,
                    yaxisscale: &#039;&amp;&#039;,
                    yaxisdomain: &#039;&amp;&#039;,
                    yaxisrange: &#039;&amp;&#039;,
                    yaxisrangeband: &#039;&amp;&#039;,
                    yaxisrangebands: &#039;&amp;&#039;,
                    yaxisshowmaxmin: &#039;@&#039;,
                    yaxishighlightzero: &#039;@&#039;,
                    yaxisrotatelabels: &#039;@&#039;,
                    yaxisrotateylabel: &#039;@&#039;,
                    yaxisstaggerlabels: &#039;@&#039;,

                    //angularjs specific
                    objectequality: &#039;@&#039;,

                    //d3.js specific
                    transitionduration: &#039;@&#039;

                },
                controller: [&#039;$scope&#039;, &#039;$element&#039;, &#039;$attrs&#039;, function ($scope, $element, $attrs) {
                    $scope.d3Call = function (data, chart) {
                        checkElementID($scope, $attrs, $element, chart, data);
                    };
                }],
                link: function (scope, element, attrs) {
                    scope.$watch(&#039;data&#039;, function (data) {
                        if (data) {
                            //if the chart exists on the scope, do not call addGraph again, update data and call the chart.
                            if (scope.chart) {
                                return scope.d3Call(data, scope.chart);
                            }
                            nv.addGraph({
                                generate: function () {
                                    setupDimensions(scope, attrs, element);
                                    var chart = nv.models.multiBarChart()
                                        .width(scope.width)
                                        .height(scope.height)
                                        .margin(scope.margin)
                                        .x(attrs.x === undefined ? function (d) { return d[0]; } : scope.x())
                                        .y(attrs.y === undefined ? function (d) { return d[1]; } : scope.y())
                                        .forceY(attrs.forcey === undefined ? [0] : scope.$eval(attrs.forcey)) // List of numbers to Force into the Y scale
                                        .showLegend(attrs.showlegend === undefined ? false : (attrs.showlegend === &quot;true&quot;))
                                        .showControls(attrs.showcontrols === undefined ? false : (attrs.showcontrols === &quot;true&quot;))
                                        .tooltips(attrs.tooltips === undefined ? false : (attrs.tooltips === &quot;true&quot;))
                                        .reduceXTicks(attrs.reducexticks === undefined ? false : (attrs.reducexticks === &quot;true&quot;))
                                        .staggerLabels(attrs.staggerlabels === undefined ? false : (attrs.staggerlabels === &quot;true&quot;))
                                        .noData(attrs.nodata === undefined ? &#039;No Data Available.&#039; : scope.nodata)
                                        .rotateLabels(attrs.rotatelabels === undefined ? 0 : attrs.rotatelabels)
                                        .color(attrs.color === undefined ? nv.utils.defaultColor() : scope.color())
                                        .delay(attrs.delay === undefined ? 1200 : attrs.delay)
                                        .stacked(attrs.stacked === undefined ? false : (attrs.stacked === &quot;true&quot;));

                                    configureXaxis(chart, scope, attrs);
                                    configureYaxis(chart, scope, attrs);
                                    processEvents(chart, scope);

                                    if (attrs.tooltipcontent) {
                                        chart.tooltipContent(scope.tooltipcontent());
                                    }

                                    scope.d3Call(data, chart);
                                    nv.utils.windowResize(chart.update);
                                    scope.chart = chart;
                                    return chart;
                                }
                            });
                        }
                    }, (attrs.objectequality === undefined ? false : (attrs.objectequality === &quot;true&quot;)));
                    
                    /*element.on(&#039;$destroy&#039; function() {
                        scope.$destroy();
                    });*/
                }
            };
        }])
        .directive(&#039;nvd3DiscreteBarChart&#039;, [function () {
            return {
                restrict: &#039;EA&#039;,
                scope: {
                    data: &#039;=&#039;,
                    width: &#039;@&#039;,
                    height: &#039;@&#039;,
                    id: &#039;@&#039;,
                    tooltips: &#039;@&#039;,
                    showxaxis: &#039;@&#039;,
                    showyaxis: &#039;@&#039;,
                    tooltipcontent: &#039;&amp;&#039;,
                    staggerlabels: &#039;@&#039;,
                    color: &#039;&amp;&#039;,
                    margin: &#039;&amp;&#039;,
                    nodata: &#039;@&#039;,
                    x: &#039;&amp;&#039;,
                    y: &#039;&amp;&#039;,
                    //forcex is not exposed in the nvd3 multibar.js file.  it is not here on purpose.
                    forcey: &#039;@&#039;,
                    showvalues: &#039;@&#039;,
                    valueformat: &#039;&amp;&#039;,

                    //xaxis
                    xaxisorient: &#039;&amp;&#039;,
                    xaxisticks: &#039;&amp;&#039;,
                    xaxistickvalues: &#039;&amp;xaxistickvalues&#039;,
                    xaxisticksubdivide: &#039;&amp;&#039;,
                    xaxisticksize: &#039;&amp;&#039;,
                    xaxistickpadding: &#039;&amp;&#039;,
                    xaxistickformat: &#039;&amp;&#039;,
                    xaxislabel: &#039;@&#039;,
                    xaxisscale: &#039;&amp;&#039;,
                    xaxisdomain: &#039;&amp;&#039;,
                    xaxisrange: &#039;&amp;&#039;,
                    xaxisrangeband: &#039;&amp;&#039;,
                    xaxisrangebands: &#039;&amp;&#039;,
                    xaxisshowmaxmin: &#039;@&#039;,
                    xaxishighlightzero: &#039;@&#039;,
                    xaxisrotatelabels: &#039;@&#039;,
                    xaxisrotateylabel: &#039;@&#039;,
                    xaxisstaggerlabels: &#039;@&#039;,

                    //yaxis
                    yaxisorient: &#039;&amp;&#039;,
                    yaxisticks: &#039;&amp;&#039;,
                    yaxistickvalues: &#039;&amp;yaxistickvalues&#039;,
                    yaxisticksubdivide: &#039;&amp;&#039;,
                    yaxisticksize: &#039;&amp;&#039;,
                    yaxistickpadding: &#039;&amp;&#039;,
                    yaxistickformat: &#039;&amp;&#039;,
                    yaxislabel: &#039;@&#039;,
                    yaxisscale: &#039;&amp;&#039;,
                    yaxisdomain: &#039;&amp;&#039;,
                    yaxisrange: &#039;&amp;&#039;,
                    yaxisrangeband: &#039;&amp;&#039;,
                    yaxisrangebands: &#039;&amp;&#039;,
                    yaxisshowmaxmin: &#039;@&#039;,
                    yaxishighlightzero: &#039;@&#039;,
                    yaxisrotatelabels: &#039;@&#039;,
                    yaxisrotateylabel: &#039;@&#039;,
                    yaxisstaggerlabels: &#039;@&#039;,

                    //angularjs specific
                    objectequality: &#039;@&#039;,

                    //d3.js specific
                    transitionduration: &#039;@&#039;

                },
                controller: [&#039;$scope&#039;, &#039;$element&#039;, &#039;$attrs&#039;, function ($scope, $element, $attrs) {
                    $scope.d3Call = function (data, chart) {
                        checkElementID($scope, $attrs, $element, chart, data);
                    };
                }],
                link: function (scope, element, attrs) {
                    scope.$watch(&#039;data&#039;, function (data) {
                        if (data) {
                            //if the chart exists on the scope, do not call addGraph again, update data and call the chart.
                            if (scope.chart) {
                                return scope.d3Call(data, scope.chart);
                            }
                            nv.addGraph({
                                generate: function () {
                                    setupDimensions(scope, attrs, element);
                                    var chart = nv.models.discreteBarChart()
                                        .width(scope.width)
                                        .height(scope.height)
                                        .margin(scope.margin)
                                        .x(attrs.x === undefined ? function (d) { return d[0]; } : scope.x())
                                        .y(attrs.y === undefined ? function (d) { return d[1]; } : scope.y())
                                        .forceY(attrs.forcey === undefined ? [0] : scope.$eval(attrs.forcey)) // List of numbers to Force into the Y scale
                                        .showValues(attrs.showvalues === undefined ? false : (attrs.showvalues === &quot;true&quot;))
                                        .tooltips(attrs.tooltips === undefined ? false : (attrs.tooltips === &quot;true&quot;))
                                        .showXAxis(attrs.showxaxis === undefined ? false : (attrs.showxaxis === &quot;true&quot;))
                                        .showYAxis(attrs.showyaxis === undefined ? false : (attrs.showyaxis === &quot;true&quot;))
                                        .noData(attrs.nodata === undefined ? &#039;No Data Available.&#039; : scope.nodata)
                                        .staggerLabels(attrs.staggerlabels === undefined ? false : (attrs.staggerlabels === &quot;true&quot;))
                                        .color(attrs.color === undefined ? nv.utils.defaultColor() : scope.color());

                                    configureXaxis(chart, scope, attrs);
                                    configureYaxis(chart, scope, attrs);

                                    if (attrs.tooltipcontent) {
                                        chart.tooltipContent(scope.tooltipcontent());
                                    }

                                    if (attrs.valueformat) {
                                        chart.valueFormat(scope.valueformat());
                                    }

                                    //events
                                    //https://github.com/mbostock/d3/wiki/Internals#wiki-dispatch
                                    //dispatch: &#039;tooltipShow&#039;, &#039;tooltipHide&#039;, &#039;beforeUpdate&#039;,
                                    //discretebar.dispatch: &#039;elementMouseout.tooltip&#039;, &#039;elementMouseover.tooltip&#039;

                                    processEvents(chart, scope);
                                    scope.d3Call(data, chart);
                                    nv.utils.windowResize(chart.update);
                                    scope.chart = chart;
                                    return chart;
                                }
                            });
                        }
                    }, (attrs.objectequality === undefined ? false : (attrs.objectequality === &quot;true&quot;)));
                }
            };
        }])
        .directive(&#039;nvd3HistoricalBarChart&#039;, [function () {
            return {
                restrict: &#039;EA&#039;,
                scope: {
                    data: &#039;=&#039;,
                    width: &#039;@&#039;,
                    height: &#039;@&#039;,
                    id: &#039;@&#039;,
                    tooltips: &#039;@&#039;,
                    tooltipcontent: &#039;&amp;&#039;,
                    color: &#039;&amp;&#039;,
                    margin: &#039;&amp;&#039;,
                    nodata: &#039;@&#039;,
                    x: &#039;&amp;&#039;,
                    y: &#039;&amp;&#039;,
                    //                forcex: &#039;@&#039;,
                    forcey: &#039;@&#039;,
                    isarea: &#039;@&#039;,
                    interactive: &#039;@&#039;,
                    clipedge: &#039;@&#039;,
                    clipvoronoi: &#039;@&#039;,
                    interpolate: &#039;@&#039;,
                    highlightPoint: &#039;@&#039;,
                    clearHighlights: &#039;@&#039;,

                    //xaxis
                    xaxisorient: &#039;&amp;&#039;,
                    xaxisticks: &#039;&amp;&#039;,
                    xaxistickvalues: &#039;&amp;xaxistickvalues&#039;,
                    xaxisticksubdivide: &#039;&amp;&#039;,
                    xaxisticksize: &#039;&amp;&#039;,
                    xaxistickpadding: &#039;&amp;&#039;,
                    xaxistickformat: &#039;&amp;&#039;,
                    xaxislabel: &#039;@&#039;,
                    xaxisscale: &#039;&amp;&#039;,
                    xaxisdomain: &#039;&amp;&#039;,
                    xaxisrange: &#039;&amp;&#039;,
                    xaxisrangeband: &#039;&amp;&#039;,
                    xaxisrangebands: &#039;&amp;&#039;,
                    xaxisshowmaxmin: &#039;@&#039;,
                    xaxishighlightzero: &#039;@&#039;,
                    xaxisrotatelabels: &#039;@&#039;,
                    xaxisrotateylabel: &#039;@&#039;,
                    xaxisstaggerlabels: &#039;@&#039;,

                    //yaxis
                    yaxisorient: &#039;&amp;&#039;,
                    yaxisticks: &#039;&amp;&#039;,
                    yaxistickvalues: &#039;&amp;yaxistickvalues&#039;,
                    yaxisticksubdivide: &#039;&amp;&#039;,
                    yaxisticksize: &#039;&amp;&#039;,
                    yaxistickpadding: &#039;&amp;&#039;,
                    yaxistickformat: &#039;&amp;&#039;,
                    yaxislabel: &#039;@&#039;,
                    yaxisscale: &#039;&amp;&#039;,
                    yaxisdomain: &#039;&amp;&#039;,
                    yaxisrange: &#039;&amp;&#039;,
                    yaxisrangeband: &#039;&amp;&#039;,
                    yaxisrangebands: &#039;&amp;&#039;,
                    yaxisshowmaxmin: &#039;@&#039;,
                    yaxishighlightzero: &#039;@&#039;,
                    yaxisrotatelabels: &#039;@&#039;,
                    yaxisrotateylabel: &#039;@&#039;,
                    yaxisstaggerlabels: &#039;@&#039;,

                    //angularjs specific
                    objectequality: &#039;@&#039;,

                    //d3.js specific
                    transitionduration: &#039;@&#039;

                },
                controller: [&#039;$scope&#039;, &#039;$element&#039;, &#039;$attrs&#039;, function ($scope, $element, $attrs) {
                    $scope.d3Call = function (data, chart) {
                        checkElementID($scope, $attrs, $element, chart, data);
                    };
                }],
                link: function (scope, element, attrs) {
                    scope.$watch(&#039;data&#039;, function (data) {
                        if (data) {
                            //if the chart exists on the scope, do not call addGraph again, update data and call the chart.
                            if (scope.chart) {
                                return scope.d3Call(data, scope.chart);
                            }
                            nv.addGraph({
                                generate: function () {
                                    setupDimensions(scope, attrs, element);
                                    var chart = nv.models.historicalBarChart()
                                        .width(scope.width)
                                        .height(scope.height)
                                        .margin(scope.margin)
                                        .x(attrs.x === undefined ? function (d) { return d[0]; } : scope.x())
                                        .y(attrs.y === undefined ? function (d) { return d[1]; } : scope.y())
                                        .forceY(attrs.forcey === undefined ? [0] : scope.$eval(attrs.forcey)) // List of numbers to Force into the Y scale
                                        .tooltips(attrs.tooltips === undefined ? false : (attrs.tooltips === &quot;true&quot;))
                                        .noData(attrs.nodata === undefined ? &#039;No Data Available.&#039; : scope.nodata)
                                        .interactive(attrs.interactive === undefined ? false : (attrs.interactive === &quot;true&quot;))
                                        .color(attrs.color === undefined ? nv.utils.defaultColor() : scope.color());

                                    configureXaxis(chart, scope, attrs);
                                    configureYaxis(chart, scope, attrs);

                                    if (chart.useInteractiveGuideline) {
                                        chart.useInteractiveGuideline(attrs.useinteractiveguideline === undefined ? false : (attrs.useinteractiveguideline === &quot;true&quot;));
                                    }

                                    if (attrs.tooltipcontent) {
                                        chart.tooltipContent(scope.tooltipcontent());
                                    }

                                    if (attrs.valueformat) {
                                        chart.valueFormat(scope.valueformat());
                                    }

                                    processEvents(chart, scope);
                                    scope.d3Call(data, chart);
                                    nv.utils.windowResize(chart.update);
                                    scope.chart = chart;
                                    return chart;
                                }
                            });
                        }
                    }, (attrs.objectequality === undefined ? false : (attrs.objectequality === &quot;true&quot;)));
                }
            };
        }])
        .directive(&#039;nvd3MultiBarHorizontalChart&#039;, [function () {
            return {
                restrict: &#039;EA&#039;,
                scope: {
                    data: &#039;=&#039;,
                    width: &#039;@&#039;,
                    height: &#039;@&#039;,
                    id: &#039;@&#039;,
                    showlegend: &#039;@&#039;,
                    tooltips: &#039;@&#039;,
                    tooltipcontent: &#039;&amp;&#039;,
                    color: &#039;&amp;&#039;,
                    showcontrols: &#039;@&#039;,
                    margin: &#039;&amp;&#039;,
                    nodata: &#039;@&#039;,
                    x: &#039;&amp;&#039;,
                    y: &#039;&amp;&#039;,
                    //forcex: &#039;@&#039;,  //forcex is rebound from multibarhorizontalchart, but is not on multibar
                    forcey: &#039;@&#039;,
                    stacked: &#039;@&#039;,
                    showvalues: &#039;@&#039;,
                    valueformat: &#039;&amp;&#039;,
                    //&#039;xDomain&#039;, &#039;yDomain&#039;,
                    //state: &#039;@&#039;, //stacked, grouped: same as stacked === true, or stacked === false

                    //xaxis
                    xaxisorient: &#039;&amp;&#039;,
                    xaxisticks: &#039;&amp;&#039;,
                    xaxistickvalues: &#039;&amp;xaxistickvalues&#039;,
                    xaxisticksubdivide: &#039;&amp;&#039;,
                    xaxisticksize: &#039;&amp;&#039;,
                    xaxistickpadding: &#039;&amp;&#039;,
                    xaxistickformat: &#039;&amp;&#039;,
                    xaxislabel: &#039;@&#039;,
                    xaxisscale: &#039;&amp;&#039;,
                    xaxisdomain: &#039;&amp;&#039;,
                    xaxisrange: &#039;&amp;&#039;,
                    xaxisrangeband: &#039;&amp;&#039;,
                    xaxisrangebands: &#039;&amp;&#039;,
                    xaxisshowmaxmin: &#039;@&#039;,
                    xaxishighlightzero: &#039;@&#039;,
                    xaxisrotatelabels: &#039;@&#039;,
                    xaxisrotateylabel: &#039;@&#039;,
                    xaxisstaggerlabels: &#039;@&#039;,

                    //yaxis
                    yaxisorient: &#039;&amp;&#039;,
                    yaxisticks: &#039;&amp;&#039;,
                    yaxistickvalues: &#039;&amp;yaxistickvalues&#039;,
                    yaxisticksubdivide: &#039;&amp;&#039;,
                    yaxisticksize: &#039;&amp;&#039;,
                    yaxistickpadding: &#039;&amp;&#039;,
                    yaxistickformat: &#039;&amp;&#039;,
                    yaxislabel: &#039;@&#039;,
                    yaxisscale: &#039;&amp;&#039;,
                    yaxisdomain: &#039;&amp;&#039;,
                    yaxisrange: &#039;&amp;&#039;,
                    yaxisrangeband: &#039;&amp;&#039;,
                    yaxisrangebands: &#039;&amp;&#039;,
                    yaxisshowmaxmin: &#039;@&#039;,
                    yaxishighlightzero: &#039;@&#039;,
                    yaxisrotatelabels: &#039;@&#039;,
                    yaxisrotateylabel: &#039;@&#039;,
                    yaxisstaggerlabels: &#039;@&#039;,

                    //angularjs specific
                    objectequality: &#039;@&#039;,

                    //d3.js specific
                    transitionduration: &#039;@&#039;

                },
                controller: [&#039;$scope&#039;, &#039;$element&#039;, &#039;$attrs&#039;, function ($scope, $element, $attrs) {
                    $scope.d3Call = function (data, chart) {
                        checkElementID($scope, $attrs, $element, chart, data);
                    };
                }],
                link: function (scope, element, attrs) {
                    scope.$watch(&#039;data&#039;, function (data) {
                        if (data) {
                            //if the chart exists on the scope, do not call addGraph again, update data and call the chart.
                            if (scope.chart) {
                                return scope.d3Call(data, scope.chart);
                            }
                            nv.addGraph({
                                generate: function () {
                                    setupDimensions(scope, attrs, element);
                                    var chart = nv.models.multiBarHorizontalChart()
                                        .width(scope.width)
                                        .height(scope.height)
                                        .margin(scope.margin)
                                        .x(attrs.x === undefined ? function (d) { return d[0]; } : scope.x())
                                        .y(attrs.y === undefined ? function (d) { return d[1]; } : scope.y())
                                        .forceY(attrs.forcey === undefined ? [0] : scope.$eval(attrs.forcey))
                                        .tooltips(attrs.tooltips === undefined ? false : (attrs.tooltips === &quot;true&quot;))
                                        .noData(attrs.nodata === undefined ? &#039;No Data Available.&#039; : scope.nodata)
                                        .color(attrs.color === undefined ? nv.utils.defaultColor() : scope.color())
                                        .showLegend(attrs.showlegend === undefined ? false : (attrs.showlegend === &quot;true&quot;))
                                        .showControls(attrs.showcontrols === undefined ? false : (attrs.showcontrols === &quot;true&quot;))
                                        .showValues(attrs.showvalues === undefined ? false : (attrs.showvalues === &quot;true&quot;))
                                        .stacked(attrs.stacked === undefined ? false : (attrs.stacked === &quot;true&quot;));

                                    configureXaxis(chart, scope, attrs);
                                    configureYaxis(chart, scope, attrs);

                                    if (attrs.tooltipcontent) {
                                        chart.tooltipContent(scope.tooltipcontent());
                                    }

                                    if (attrs.valueformat) {
                                        chart.valueFormat(scope.valueformat());
                                    }

                                    scope.d3Call(data, chart);
                                    nv.utils.windowResize(chart.update);
                                    scope.chart = chart;
                                    return chart;
                                }
                            });
                        }
                    }, (attrs.objectequality === undefined ? false : (attrs.objectequality === &quot;true&quot;)));
                    
                    /*element.on(&#039;$destroy&#039; function() {
                        scope.$destroy();
                    });*/
                }
            };
        }])
        .directive(&#039;nvd3PieChart&#039;, [function () {
            return {
                restrict: &#039;EA&#039;,
                scope: {
                    data: &#039;=&#039;,
                    width: &#039;@&#039;,
                    height: &#039;@&#039;,
                    id: &#039;@&#039;,
                    showlabels: &#039;@&#039;,
                    showlegend: &#039;@&#039;,
                    donutLabelsOutside: &#039;@&#039;,
                    pieLabelsOutside: &#039;@&#039;,
                    labelType: &#039;@&#039;,
                    nodata: &#039;@&#039;,
                    margin: &#039;&amp;&#039;,
                    x: &#039;&amp;&#039;,
                    y: &#039;&amp;&#039;,
                    color: &#039;&amp;&#039;,
                    donut: &#039;@&#039;,
                    donutRatio: &#039;@&#039;,
                    labelThreshold: &#039;@&#039;,
                    description: &#039;&amp;&#039;,
                    tooltips: &#039;@&#039;,
                    tooltipcontent: &#039;&amp;&#039;,
                    valueFormat: &#039;&amp;&#039;,

                    //angularjs specific
                    objectequality: &#039;@&#039;,

                    //d3.js specific
                    transitionduration: &#039;@&#039;

                },
                controller: [&#039;$scope&#039;, &#039;$element&#039;, &#039;$attrs&#039;, function ($scope, $element, $attrs) {
                    $scope.d3Call = function (data, chart) {
                        checkElementID($scope, $attrs, $element, chart, data);
                    };
                }],
                link: function (scope, element, attrs) {
                    scope.$watch(&#039;data&#039;, function (data) {
                        if (data) {
                            //if the chart exists on the scope, do not call addGraph again, update data and call the chart.
                            if (scope.chart) {
                                return scope.d3Call(data, scope.chart);
                            }
                            nv.addGraph({
                                generate: function () {
                                    setupDimensions(scope, attrs, element);
                                    var chart = nv.models.pieChart()
                                        .x(attrs.x === undefined ? function (d) { return d[0]; } : scope.x())
                                        .y(attrs.y === undefined ? function (d) { return d[1]; } : scope.y())
                                        .width(scope.width)
                                        .height(scope.height)
                                        .margin(scope.margin)
                                        .tooltips(attrs.tooltips === undefined ? false : (attrs.tooltips === &quot;true&quot;))
                                        .noData(attrs.nodata === undefined ? &#039;No Data Available.&#039; : scope.nodata)
                                        .showLabels(attrs.showlabels === undefined ? false : (attrs.showlabels === &quot;true&quot;))
                                        .labelThreshold(attrs.labelThreshold === undefined ? 0.02 : attrs.labelthreshold)
                                        .labelType(attrs.labeltype === undefined ? &#039;key&#039; : attrs.labeltype)
                                        .pieLabelsOutside(attrs.pielabelsoutside === undefined ? true : (attrs.pielabelsoutside === &quot;true&quot;))
                                        .valueFormat(attrs.valueformat === undefined ? d3.format(&#039;,.2f&#039;) : attrs.valueformat)
                                        .showLegend(attrs.showlegend === undefined ? false : (attrs.showlegend === &quot;true&quot;))
                                        .description(attrs.description === undefined ? function (d) { return d.description; } : scope.description())
                                        .color(attrs.color === undefined ? nv.utils.defaultColor() : scope.color())
                                        .donutLabelsOutside(attrs.donutlabelsoutside === undefined ? false : (attrs.donutlabelsoutside === &quot;true&quot;))
                                        .donut(attrs.donut === undefined ? false : (attrs.donut === &quot;true&quot;))
                                        .donutRatio(attrs.donutratio === undefined ? 0.5 : (attrs.donutratio));

                                    if (attrs.tooltipcontent) {
                                        chart.tooltipContent(scope.tooltipcontent());
                                    }
                                    processEvents(chart, scope);
                                    scope.d3Call(data, chart);
                                    nv.utils.windowResize(chart.update);
                                    scope.chart = chart;
                                    return chart;
                                }
                            });
                        }
                    }, (attrs.objectequality === undefined ? false : (attrs.objectequality === &quot;true&quot;)));
                }
            };
        }])
        .directive(&#039;nvd3ScatterChart&#039;, [function () {
            return {
                restrict: &#039;EA&#039;,
                scope: {
                    data: &#039;=&#039;,
                    width: &#039;@&#039;,
                    height: &#039;@&#039;,
                    id: &#039;@&#039;,
                    showlegend: &#039;@&#039;,
                    tooltips: &#039;@&#039;,
                    showcontrols: &#039;@&#039;,
                    showDistX: &#039;@&#039;,
                    showDistY: &#039;@&#039;,
                    rightAlignYAxis: &#039;@&#039;,
                    fisheye: &#039;@&#039;,
                    xPadding: &#039;@&#039;,
                    yPadding: &#039;@&#039;,
                    tooltipContent: &#039;&amp;&#039;,
                    tooltipXContent: &#039;&amp;&#039;,
                    tooltipYContent: &#039;&amp;&#039;,
                    color: &#039;&amp;&#039;,
                    margin: &#039;&amp;&#039;,
                    nodata: &#039;@&#039;,
                    transitionDuration: &#039;@&#039;,
                    shape: &#039;&amp;&#039;,
                    onlyCircles: &#039;@&#039;,
                    interactive: &#039;@&#039;,
                    x: &#039;&amp;&#039;,
                    y: &#039;&amp;&#039;,
                    size: &#039;&amp;&#039;,
                    forceX: &#039;@&#039;,
                    forceY: &#039;@&#039;,
                    forceSize: &#039;@&#039;,
                    xrange: &#039;&amp;&#039;,
                    xdomain: &#039;&amp;&#039;,
                    xscale: &#039;&amp;&#039;,
                    yrange: &#039;&amp;&#039;,
                    ydomain: &#039;&amp;&#039;,
                    yscale: &#039;&amp;&#039;,
                    sizerange: &#039;&amp;&#039;,
                    sizedomain: &#039;&amp;&#039;,
                    zscale: &#039;&amp;&#039;,

                    //xaxis
                    xaxisorient: &#039;&amp;&#039;,
                    xaxisticks: &#039;&amp;&#039;,
                    xaxistickvalues: &#039;&amp;xaxistickvalues&#039;,
                    xaxisticksubdivide: &#039;&amp;&#039;,
                    xaxisticksize: &#039;&amp;&#039;,
                    xaxistickpadding: &#039;&amp;&#039;,
                    xaxistickformat: &#039;&amp;&#039;,
                    xaxislabel: &#039;@&#039;,
                    xaxisscale: &#039;&amp;&#039;,
                    xaxisdomain: &#039;&amp;&#039;,
                    xaxisrange: &#039;&amp;&#039;,
                    xaxisrangeband: &#039;&amp;&#039;,
                    xaxisrangebands: &#039;&amp;&#039;,
                    xaxisshowmaxmin: &#039;@&#039;,
                    xaxishighlightzero: &#039;@&#039;,
                    xaxisrotatelabels: &#039;@&#039;,
                    xaxisrotateylabel: &#039;@&#039;,
                    xaxisstaggerlabels: &#039;@&#039;,

                    //yaxis
                    yaxisorient: &#039;&amp;&#039;,
                    yaxisticks: &#039;&amp;&#039;,
                    yaxistickvalues: &#039;&amp;yaxistickvalues&#039;,
                    yaxisticksubdivide: &#039;&amp;&#039;,
                    yaxisticksize: &#039;&amp;&#039;,
                    yaxistickpadding: &#039;&amp;&#039;,
                    yaxistickformat: &#039;&amp;&#039;,
                    yaxislabel: &#039;@&#039;,
                    yaxisscale: &#039;&amp;&#039;,
                    yaxisdomain: &#039;&amp;&#039;,
                    yaxisrange: &#039;&amp;&#039;,
                    yaxisrangeband: &#039;&amp;&#039;,
                    yaxisrangebands: &#039;&amp;&#039;,
                    yaxisshowmaxmin: &#039;@&#039;,
                    yaxishighlightzero: &#039;@&#039;,
                    yaxisrotatelabels: &#039;@&#039;,
                    yaxisrotateylabel: &#039;@&#039;,
                    yaxisstaggerlabels: &#039;@&#039;,

                    //angularjs specific
                    objectequality: &#039;@&#039;,

                    //d3.js specific
                    transitionduration: &#039;@&#039;

                },
                controller: [&#039;$scope&#039;, &#039;$element&#039;, &#039;$attrs&#039;, function ($scope, $element, $attrs) {
                    $scope.d3Call = function (data, chart) {
                        checkElementID($scope, $attrs, $element, chart, data);
                    };
                }],
                link: function (scope, element, attrs) {
                    scope.$watch(&#039;data&#039;, function (data) {
                        if (data) {
                            //if the chart exists on the scope, do not call addGraph again, update data and call the chart.
                            if (scope.chart) {
                                return scope.d3Call(data, scope.chart);
                            }
                            nv.addGraph({
                                generate: function () {
                                    setupDimensions(scope, attrs, element);
                                    var chart = nv.models.scatterChart()
                                        .width(scope.width)
                                        .height(scope.height)
                                        .margin(scope.margin)
                                        .x(attrs.x === undefined ? function (d) { return d.x; } : scope.x())
                                        .y(attrs.y === undefined ? function (d) { return d.y; } : scope.y())
                                        .size(attrs.size === undefined ? function (d) { return d.size; } : scope.size())
                                        .forceX(attrs.forcex === undefined ? [] : scope.$eval(attrs.forcex))
                                        .forceY(attrs.forcey === undefined ? [] : scope.$eval(attrs.forcey))
                                        .forceSize(attrs.forcesize === undefined ? [] : scope.$eval(attrs.forcesize))
                                        .interactive(attrs.interactive === undefined ? false : (attrs.interactive === &quot;true&quot;))
                                        .tooltips(attrs.tooltips === undefined ? false : (attrs.tooltips === &quot;true&quot;))
                                        .tooltipContent(attrs.tooltipContent === undefined ? null : scope.tooltipContent())
                                        .tooltipXContent(attrs.tooltipxcontent === undefined ? function (key, x) { return &#039;&lt;strong&gt;&#039; + x + &#039;&lt;/strong&gt;&#039;; } : scope.tooltipXContent())
                                        .tooltipYContent(attrs.tooltipycontent === undefined ? function (key, x, y) { return &#039;&lt;strong&gt;&#039; + y + &#039;&lt;/strong&gt;&#039;; } : scope.tooltipYContent())
                                        .showControls(attrs.showcontrols === undefined ? false : (attrs.showcontrols === &quot;true&quot;))
                                        .showLegend(attrs.showlegend === undefined ? false : (attrs.showlegend === &quot;true&quot;))
                                        .showDistX(attrs.showdistx === undefined ? false : (attrs.showdistx === &quot;true&quot;))
                                        .showDistY(attrs.showdisty === undefined ? false : (attrs.showdisty === &quot;true&quot;))
                                        .xPadding(attrs.xpadding === undefined ? 0 : (+attrs.xpadding))
                                        .yPadding(attrs.ypadding === undefined ? 0 : (+attrs.ypadding))
                                        .fisheye(attrs.fisheye === undefined ? 0 : (+attrs.fisheye))
                                        .noData(attrs.nodata === undefined ? &#039;No Data Available.&#039; : scope.nodata)
                                        .color(attrs.color === undefined ? nv.utils.defaultColor() : scope.color())
                                        .transitionDuration(attrs.transitionduration === undefined ? 250 : (+attrs.transitionduration));

                                    if (attrs.shape) {
                                        chart.scatter.onlyCircles(false);
                                        chart.scatter.shape(attrs.shape === undefined ? function (d) { return d.shape || &#039;circle&#039;; } : scope.shape());
                                    }

                                    //&#039;pointActive&#039;, &#039;clipVoronoi&#039;, &#039;clipRadius&#039;, &#039;useVoronoi&#039;

                                    configureXaxis(chart, scope, attrs);
                                    configureYaxis(chart, scope, attrs);

                                    if (attrs.xscale) {
                                        chart.xDomain(scope.xdomain());
                                        chart.xRange(scope.xrange());
                                        chart.xScale(scope.xscale());
                                    }

                                    if (attrs.yscale) {
                                        chart.yDomain(scope.ydomain());
                                        chart.yRange(scope.yrange());
                                        chart.yScale(scope.yscale());
                                    }

                                    if (attrs.zscale) {
                                        chart.sizeDomain(scope.sizedomain());
                                        chart.sizeRange(scope.sizerange());
                                        chart.zScale(scope.zscale());
                                    }

                                    processEvents(chart, scope);
                                    scope.d3Call(data, chart);
                                    nv.utils.windowResize(chart.update);
                                    scope.chart = chart;
                                    return chart;
                                }
                            });
                        }
                    }, (attrs.objectequality === undefined ? false : (attrs.objectequality === &quot;true&quot;)));
                }
            };
        }])
        .directive(&#039;nvd3ScatterPlusLineChart&#039;, [function () {
            return {
                restrict: &#039;EA&#039;,
                scope: {
                    data: &#039;=&#039;,
                    width: &#039;@&#039;,
                    height: &#039;@&#039;,
                    id: &#039;@&#039;
                },
                controller: [&#039;$scope&#039;, &#039;$element&#039;, &#039;$attrs&#039;, function ($scope, $element, $attrs) {
                    $scope.d3Call = function (data, chart) {
                        checkElementID($scope, $attrs, $element, chart, data);
                    };
                }],
                link: function (scope, element, attrs) {
                    scope.$watch(&#039;data&#039;, function (data) {
                        if (data) {

                            if (scope.chart) {
                                return scope.d3Call(data, scope.chart);
                            }
                            nv.addGraph({
                                generate: function () {
                                    setupDimensions(scope, attrs, element);
                                    var chart = nv.models.scatterPlusLineChart()
                                        .width(scope.width)
                                        .height(scope.height)
                                        .margin(scope.margin)
                                        .x(attrs.x === undefined ? function (d) { return d.x; } : scope.x())
                                        .y(attrs.y === undefined ? function (d) { return d.y; } : scope.y())
                                        .size(attrs.size === undefined ? function (d) { return d.size; } : scope.size())
                                        .interactive(attrs.interactive === undefined ? false : (attrs.interactive === &quot;true&quot;))
                                        .tooltips(attrs.tooltips === undefined ? false : (attrs.tooltips === &quot;true&quot;))
                                        .tooltipContent(attrs.tooltipContent === undefined ? null : scope.tooltipContent())
                                        .tooltipXContent(attrs.tooltipxcontent === undefined ? function (key, x) { return &#039;&lt;strong&gt;&#039; + x + &#039;&lt;/strong&gt;&#039;; } : scope.tooltipXContent())
                                        .tooltipYContent(attrs.tooltipycontent === undefined ? function (key, x, y) { return &#039;&lt;strong&gt;&#039; + y + &#039;&lt;/strong&gt;&#039;; } : scope.tooltipYContent())
                                        .showControls(attrs.showcontrols === undefined ? false : (attrs.showcontrols === &quot;true&quot;))
                                        .showLegend(attrs.showlegend === undefined ? false : (attrs.showlegend === &quot;true&quot;))
                                        .showDistX(attrs.showdistx === undefined ? false : (attrs.showdistx === &quot;true&quot;))
                                        .showDistY(attrs.showdisty === undefined ? false : (attrs.showdisty === &quot;true&quot;))
                                        .xPadding(attrs.xpadding === undefined ? 0 : (+attrs.xpadding))
                                        .yPadding(attrs.ypadding === undefined ? 0 : (+attrs.ypadding))
                                        .fisheye(attrs.fisheye === undefined ? 0 : (+attrs.fisheye))
                                        .noData(attrs.nodata === undefined ? &#039;No Data Available.&#039; : scope.nodata)
                                        .color(attrs.color === undefined ? nv.utils.defaultColor() : scope.color())
                                        .transitionDuration(attrs.transitionduration === undefined ? 250 : (+attrs.transitionduration));

                                    if (attrs.shape) {
                                        chart.scatter.onlyCircles(false);
                                        chart.scatter.shape(attrs.shape === undefined ? function (d) { return d.shape || &#039;circle&#039;; } : scope.shape());
                                    }

                                    processEvents(chart, scope);
                                    scope.d3Call(data, chart);
                                    nv.utils.windowResize(chart.update);
                                    scope.chart = chart;
                                    return chart;
                                }
                            });
                        }
                    });
                }
            };
        }])
        .directive(&#039;nvd3LinePlusBarChart&#039;, [function () {
            &#039;use strict&#039;;
            return {
                restrict: &#039;EA&#039;,
                scope: {
                    data: &#039;=&#039;,
                    width: &#039;@&#039;,
                    height: &#039;@&#039;,
                    id: &#039;@&#039;,
                    showlegend: &#039;@&#039;,
                    tooltips: &#039;@&#039;,
                    showxaxis: &#039;@&#039;,
                    showyaxis: &#039;@&#039;,
                    rightalignyaxis: &#039;@&#039;,
                    defaultstate: &#039;@&#039;,
                    nodata: &#039;@&#039;,
                    margin: &#039;&amp;&#039;,
                    tooltipcontent: &#039;&amp;&#039;,
                    color: &#039;&amp;&#039;,
                    x: &#039;&amp;&#039;,
                    y: &#039;&amp;&#039;,
                    clipvoronoi: &#039;@&#039;,
                    interpolate: &#039;@&#039;,
                    //                &#039;xScale&#039;, &#039;yScale&#039;, &#039;xDomain&#039;, &#039;yDomain&#039;, defined

                    //xaxis
                    xaxisorient: &#039;&amp;&#039;,
                    xaxisticks: &#039;&amp;&#039;,
                    xaxistickvalues: &#039;&amp;xaxistickvalues&#039;,
                    xaxisticksubdivide: &#039;&amp;&#039;,
                    xaxisticksize: &#039;&amp;&#039;,
                    xaxistickpadding: &#039;&amp;&#039;,
                    xaxistickformat: &#039;&amp;&#039;,
                    xaxislabel: &#039;@&#039;,
                    xaxisscale: &#039;&amp;&#039;,
                    xaxisdomain: &#039;&amp;&#039;,
                    xaxisrange: &#039;&amp;&#039;,
                    xaxisrangeband: &#039;&amp;&#039;,
                    xaxisrangebands: &#039;&amp;&#039;,
                    xaxisshowmaxmin: &#039;@&#039;,
                    xaxishighlightzero: &#039;@&#039;,
                    xaxisrotatelabels: &#039;@&#039;,
                    xaxisrotateylabel: &#039;@&#039;,
                    xaxisstaggerlabels: &#039;@&#039;,

                    //yaxis
                    yaxisorient: &#039;&amp;&#039;,
                    yaxisticks: &#039;&amp;&#039;,
                    yaxistickvalues: &#039;&amp;yaxistickvalues&#039;,
                    yaxisticksubdivide: &#039;&amp;&#039;,
                    yaxisticksize: &#039;&amp;&#039;,
                    yaxistickpadding: &#039;&amp;&#039;,
                    yaxistickformat: &#039;&amp;&#039;,
                    yaxislabel: &#039;@&#039;,
                    yaxisscale: &#039;&amp;&#039;,
                    yaxisdomain: &#039;&amp;&#039;,
                    yaxisrange: &#039;&amp;&#039;,
                    yaxisrangeband: &#039;&amp;&#039;,
                    yaxisrangebands: &#039;&amp;&#039;,
                    yaxisshowmaxmin: &#039;@&#039;,
                    yaxishighlightzero: &#039;@&#039;,
                    yaxisrotatelabels: &#039;@&#039;,
                    yaxisrotateylabel: &#039;@&#039;,
                    yaxisstaggerlabels: &#039;@&#039;,

                    //yaxis
                    y2axisorient: &#039;&amp;&#039;,
                    y2axisticks: &#039;&amp;&#039;,
                    y2axistickvalues: &#039;&amp;&#039;,
                    y2axisticksubdivide: &#039;&amp;&#039;,
                    y2axisticksize: &#039;&amp;&#039;,
                    y2axistickpadding: &#039;&amp;&#039;,
                    y2axistickformat: &#039;&amp;&#039;,
                    y2axislabel: &#039;&amp;&#039;,
                    y2axisscale: &#039;&amp;&#039;,
                    y2axisdomain: &#039;&amp;&#039;,
                    y2axisrange: &#039;&amp;&#039;,
                    y2axisrangeband: &#039;&amp;&#039;,
                    y2axisrangebands: &#039;&amp;&#039;,
                    y2axisshowmaxmin: &#039;@&#039;,
                    y2axishighlightzero: &#039;@&#039;,
                    y2axisrotatelabels: &#039;@&#039;,
                    y2axisrotateylabel: &#039;@&#039;,
                    y2axisstaggerlabels: &#039;@&#039;,

                    //angularjs specific
                    objectequality: &#039;@&#039;,

                    //d3.js specific
                    transitionduration: &#039;@&#039;

                },
                controller: [&#039;$scope&#039;, &#039;$element&#039;, &#039;$attrs&#039;, function ($scope, $element, $attrs) {
                    $scope.d3Call = function (data, chart) {
                        checkElementID($scope, $attrs, $element, chart, data);
                    };
                }],
                link: function (scope, element, attrs) {
                    scope.$watch(&#039;data&#039;, function (data) {
                        if (data) {
                            //if the chart exists on the scope, do not call addGraph again, update data and call the chart.
                            if (scope.chart) {
                                return scope.d3Call(data, scope.chart);
                            }
                            nv.addGraph({
                                generate: function () {
                                    setupDimensions(scope, attrs, element);
                                    var chart = nv.models.linePlusBarChart()
                                        .width(scope.width)
                                        .height(scope.height)
                                        .margin(scope.margin)
                                        .x(attrs.x === undefined ? function (d) { return d[0]; } : scope.x())
                                        .y(attrs.y === undefined ? function (d) { return d[1]; } : scope.y())
                                        .showLegend(attrs.showlegend === undefined ? false : (attrs.showlegend === &quot;true&quot;))
                                        .tooltips(attrs.tooltips === undefined ? false : (attrs.tooltips === &quot;true&quot;))
                                        .noData(attrs.nodata === undefined ? &#039;No Data Available.&#039; : scope.nodata)
                                        .interpolate(attrs.interpolate === undefined ? &#039;linear&#039; : attrs.interpolate)
                                        .color(attrs.color === undefined ? nv.utils.defaultColor() : scope.color());

                                    if (attrs.tooltipcontent) {
                                        chart.tooltipContent(scope.tooltipcontent());
                                    }

                                    configureXaxis(chart, scope, attrs);
                                    configureY1axis(chart, scope, attrs);
                                    configureY2axis(chart, scope, attrs);
                                    processEvents(chart, scope);
                                    scope.d3Call(data, chart);
                                    nv.utils.windowResize(chart.update);
                                    scope.chart = chart;
                                    return chart;
                                }
                            });
                        }
                    }, (attrs.objectequality === undefined ? false : (attrs.objectequality === &quot;true&quot;)));
                }
            };
        }])
        .directive(&#039;nvd3LineWithFocusChart&#039;, [function () {
            &#039;use strict&#039;;
            return {
                restrict: &#039;EA&#039;,
                scope: {
                    data: &#039;=&#039;,
                    width: &#039;@&#039;,
                    height: &#039;@&#039;,
                    height2: &#039;@&#039;,
                    id: &#039;@&#039;,
                    showlegend: &#039;@&#039;,
                    tooltips: &#039;@&#039;,
                    showxaxis: &#039;@&#039;,
                    showyaxis: &#039;@&#039;,
                    rightalignyaxis: &#039;@&#039;,
                    defaultstate: &#039;@&#039;,
                    nodata: &#039;@&#039;,
                    margin: &#039;@&#039;,
                    margin2: &#039;@&#039;,
                    tooltipcontent: &#039;&amp;&#039;,
                    color: &#039;&amp;&#039;,
                    x: &#039;&amp;&#039;,
                    y: &#039;&amp;&#039;,
                    clipvoronoi: &#039;@&#039;,
                    interpolate: &#039;@&#039;,
                    isArea: &#039;@&#039;,
                    //                &#039;xScale&#039;, &#039;yScale&#039;, &#039;xDomain&#039;, &#039;yDomain&#039;, defined

                    //xaxis
                    xaxisorient: &#039;&amp;&#039;,
                    xaxisticks: &#039;&amp;&#039;,
                    xaxistickvalues: &#039;&amp;xaxistickvalues&#039;,
                    xaxisticksubdivide: &#039;&amp;&#039;,
                    xaxisticksize: &#039;&amp;&#039;,
                    xaxistickpadding: &#039;&amp;&#039;,
                    xaxistickformat: &#039;&amp;&#039;,
                    xaxislabel: &#039;@&#039;,
                    xaxisscale: &#039;&amp;&#039;,
                    xaxisdomain: &#039;&amp;&#039;,
                    xaxisrange: &#039;&amp;&#039;,
                    xaxisrangeband: &#039;&amp;&#039;,
                    xaxisrangebands: &#039;&amp;&#039;,
                    xaxisshowmaxmin: &#039;@&#039;,
                    xaxishighlightzero: &#039;@&#039;,
                    xaxisrotatelabels: &#039;@&#039;,
                    xaxisrotateylabel: &#039;@&#039;,
                    xaxisstaggerlabels: &#039;@&#039;,

                    //x2axis
                    x2axisorient: &#039;&amp;&#039;,
                    x2axisticks: &#039;&amp;&#039;,
                    x2axistickvalues: &#039;&amp;xaxistickvalues&#039;,
                    x2axisticksubdivide: &#039;&amp;&#039;,
                    x2axisticksize: &#039;&amp;&#039;,
                    x2axistickpadding: &#039;&amp;&#039;,
                    x2axistickformat: &#039;&amp;&#039;,
                    x2axislabel: &#039;@&#039;,
                    x2axisscale: &#039;&amp;&#039;,
                    x2axisdomain: &#039;&amp;&#039;,
                    x2axisrange: &#039;&amp;&#039;,
                    x2axisrangeband: &#039;&amp;&#039;,
                    x2axisrangebands: &#039;&amp;&#039;,
                    x2axisshowmaxmin: &#039;@&#039;,
                    x2axishighlightzero: &#039;@&#039;,
                    x2axisrotatelables: &#039;@&#039;,
                    x2axisrotateylabel: &#039;@&#039;,
                    x2axisstaggerlabels: &#039;@&#039;,

                    //yaxis
                    yaxisorient: &#039;&amp;&#039;,
                    yaxisticks: &#039;&amp;&#039;,
                    yaxistickvalues: &#039;&amp;yaxistickvalues&#039;,
                    yaxisticksubdivide: &#039;&amp;&#039;,
                    yaxisticksize: &#039;&amp;&#039;,
                    yaxistickpadding: &#039;&amp;&#039;,
                    yaxistickformat: &#039;&amp;&#039;,
                    yaxislabel: &#039;@&#039;,
                    yaxisscale: &#039;&amp;&#039;,
                    yaxisdomain: &#039;&amp;&#039;,
                    yaxisrange: &#039;&amp;&#039;,
                    yaxisrangeband: &#039;&amp;&#039;,
                    yaxisrangebands: &#039;&amp;&#039;,
                    yaxisshowmaxmin: &#039;@&#039;,
                    yaxishighlightzero: &#039;@&#039;,
                    yaxisrotatelabels: &#039;@&#039;,
                    yaxisrotateylabel: &#039;@&#039;,
                    yaxisstaggerlabels: &#039;@&#039;,

                    //yaxis
                    y2axisorient: &#039;&amp;&#039;,
                    y2axisticks: &#039;&amp;&#039;,
                    y2axistickvalues: &#039;&amp;&#039;,
                    y2axisticksubdivide: &#039;&amp;&#039;,
                    y2axisticksize: &#039;&amp;&#039;,
                    y2axistickpadding: &#039;&amp;&#039;,
                    y2axistickformat: &#039;&amp;&#039;,
                    y2axislabel: &#039;&amp;&#039;,
                    y2axisscale: &#039;&amp;&#039;,
                    y2axisdomain: &#039;&amp;&#039;,
                    y2axisrange: &#039;&amp;&#039;,
                    y2axisrangeband: &#039;&amp;&#039;,
                    y2axisrangebands: &#039;&amp;&#039;,
                    y2axisshowmaxmin: &#039;@&#039;,
                    y2axishighlightzero: &#039;@&#039;,
                    y2axisrotatelabels: &#039;@&#039;,
                    y2axisrotateylabel: &#039;@&#039;,
                    y2axisstaggerlabels: &#039;@&#039;,

                    //angularjs specific
                    objectequality: &#039;@&#039;,

                    //d3.js specific
                    transitionduration: &#039;@&#039;

                },
                controller: [&#039;$scope&#039;, &#039;$element&#039;, &#039;$attrs&#039;, function ($scope, $element, $attrs) {
                    $scope.d3Call = function (data, chart) {
                        checkElementID($scope, $attrs, $element, chart, data);
                    };
                }],
                link: function (scope, element, attrs) {
                    scope.$watch(&#039;data&#039;, function (data) {
                        if (data) {
                            //if the chart exists on the scope, do not call addGraph again, update data and call the chart.
                            if (scope.chart) {
                                return scope.d3Call(data, scope.chart);
                            }
                            nv.addGraph({
                                generate: function () {
                                    setupDimensions(scope, attrs, element);

                                    //setup height 2
                                    //height 2 is 100

                                    //margin
                                    //nvd3 default is {top: 30, right: 30, bottom: 30, left: 60}

                                    //setup margin 2
                                    //nvd3 default is {top: 0, right: 30, bottom: 20, left: 60}

                                    var chart = nv.models.lineWithFocusChart()
                                        .width(scope.width)
                                        .height(scope.height)
                                        .height2((attrs.height2 === undefined ? 100 : (+attrs.height2)))
                                        .margin(scope.margin)
                                        .margin2(scope.margin2)
                                        .x(attrs.x === undefined ? function (d) { return d[0]; } : scope.x())
                                        .y(attrs.y === undefined ? function (d) { return d[1]; } : scope.y())
                                        .showLegend(attrs.showlegend === undefined ? false : (attrs.showlegend === &quot;true&quot;))
                                        .tooltips(attrs.tooltips === undefined ? false : (attrs.tooltips === &quot;true&quot;))
                                        .noData(attrs.nodata === undefined ? &#039;No Data Available.&#039; : scope.nodata)
                                        .color(attrs.color === undefined ? nv.utils.defaultColor() : scope.color())
                                        .isArea(attrs.isarea === undefined ? function () { return false; } : function () { return (attrs.isarea === &quot;true&quot;); })
                                        .interpolate(attrs.interpolate === undefined ? &#039;linear&#039; : attrs.interpolate);

                                    if (attrs.tooltipcontent) {
                                        chart.tooltipContent(scope.tooltipcontent());
                                    }

                                    configureXaxis(chart, scope, attrs);
                                    configureX2axis(chart, scope, attrs);
                                    configureY1axis(chart, scope, attrs);
                                    configureY2axis(chart, scope, attrs);
                                    processEvents(chart, scope);
                                    scope.d3Call(data, chart);
                                    nv.utils.windowResize(chart.update);
                                    scope.chart = chart;
                                    return chart;
                                }
                            });
                        }
                    }, (attrs.objectequality === undefined ? false : (attrs.objectequality === &quot;true&quot;)));
                    
                    element.$on(&#039;$destroy&#039;, function() {
                        console.log(&#039;NVD3: hulk, distruggeeeee!!&#039;);
                        scope.$destroy();
                    });
                }
            };
        }])
        .directive(&#039;nvd3BulletChart&#039;, [function () {
            &#039;use strict&#039;;
            return {
                restrict: &#039;EA&#039;,
                scope: {
                    data: &#039;=&#039;,
                    width: &#039;@&#039;,
                    height: &#039;@&#039;,
                    id: &#039;@&#039;,
                    margin: &#039;&amp;&#039;,
                    tooltips: &#039;@&#039;,
                    tooltipcontent: &#039;&amp;&#039;,
                    orient: &#039;@&#039;,  // left, right, top, bottom
                    ranges: &#039;&amp;&#039;, //ranges (bad, satisfactory, good)
                    markers: &#039;&amp;&#039;, // markers (previous, goal)
                    measures: &#039;&amp;&#039;, // measures (actual, forecast)
                    tickformat: &#039;&amp;&#039;,
                    nodata: &#039;@&#039;,

                    //angularjs specific
                    objectequality: &#039;@&#039;,

                    //d3.js specific
                    transitionduration: &#039;@&#039;

                },
                controller: [&#039;$scope&#039;, &#039;$element&#039;, &#039;$attrs&#039;, function ($scope, $element, $attrs) {
                    $scope.d3Call = function (data, chart) {
                        checkElementID($scope, $attrs, $element, chart, data);
                    };
                }],
                link: function (scope, element, attrs) {
                    scope.$watch(&#039;data&#039;, function (data) {
                        if (data) {
                            //if the chart exists on the scope, do not call addGraph again, update data and call the chart.
                            if (scope.chart) {
                                return scope.d3Call(data, scope.chart);
                            }
                            nv.addGraph({
                                generate: function () {
                                    setupDimensions(scope, attrs, element);
                                    var chart = nv.models.bulletChart()
                                        .width(scope.width)
                                        .height(scope.height)
                                        .margin(scope.margin)
                                        .orient(attrs.orient === undefined ? &#039;left&#039; : attrs.orient)
    //                                    .ranges(attrs.ranges === undefined ? function(d){ return d.ranges; } : scope.ranges())
    //                                    .markers(attrs.markers === undefined ? function(d){ return d.markers; } : scope.markers())
    //                                    .measures(attrs.measures === undefined ? function(d){ return d.measures; } : scope.measures())
                                        .tickFormat(attrs.tickformat === undefined ? null : scope.tickformat())
                                        .tooltips(attrs.tooltips === undefined ? false : (attrs.tooltips === &quot;true&quot;))
                                        .noData(attrs.nodata === undefined ? &#039;No Data Available.&#039; : scope.nodata);

                                    if (attrs.tooltipcontent) {
                                        chart.tooltipContent(scope.tooltipcontent());
                                    }

                                    processEvents(chart, scope);
                                    scope.d3Call(data, chart);
                                    nv.utils.windowResize(chart.update);
                                    scope.chart = chart;
                                    return chart;
                                }
                            });
                        }
                    }, (attrs.objectequality === undefined ? false : (attrs.objectequality === &quot;true&quot;)));
                }
            };
        }])
        .directive(&#039;nvd3SparklineChart&#039;, [function () {
            &#039;use strict&#039;;
            return {
                restrict: &#039;EA&#039;,
                scope: {
                    data: &#039;=&#039;,
                    width: &#039;@&#039;,
                    height: &#039;@&#039;,
                    id: &#039;@&#039;,
                    margin: &#039;&amp;&#039;,
                    x: &#039;&amp;&#039;,
                    y: &#039;&amp;&#039;,
                    color: &#039;&amp;&#039;,
                    xscale: &#039;&amp;&#039;,
                    yscale: &#039;&amp;&#039;,
                    showvalue: &#039;@&#039;,
                    alignvalue: &#039;@&#039;,
                    rightalignvalue: &#039;@&#039;,
                    nodata: &#039;@&#039;,

                    xaxistickformat: &#039;&amp;&#039;,
                    yaxistickformat: &#039;&amp;&#039;,

                    //angularjs specific
                    objectequality: &#039;@&#039;,

                    //d3.js specific
                    transitionduration: &#039;@&#039;

                },
                controller: [&#039;$scope&#039;, &#039;$element&#039;, &#039;$attrs&#039;, function ($scope, $element, $attrs) {
                    $scope.d3Call = function (data, chart) {
                        checkElementID($scope, $attrs, $element, chart, data);
                    };
                }],
                link: function (scope, element, attrs) {
                    scope.$watch(&#039;data&#039;, function (data) {
                        if (data) {
                            //if the chart exists on the scope, do not call addGraph again, update data and call the chart.
                            if (scope.chart) {
                                return scope.d3Call(data, scope.chart);
                            }
                            nv.addGraph({
                                generate: function () {
                                    setupDimensions(scope, attrs, element);
                                    var chart = nv.models.sparklinePlus()
                                        .width(scope.width)
                                        .height(scope.height)
                                        .margin(scope.margin)
                                        .x(attrs.x === undefined ? function (d) { return d.x; } : scope.x())
                                        .y(attrs.y === undefined ? function (d) { return d.y; } : scope.y())
                                        .color(attrs.color === undefined ? nv.utils.getColor([&#039;#000&#039;]) : scope.color())
                                        .showValue(attrs.showvalue === undefined ? true : (attrs.showvalue === &quot;true&quot;))
                                        .alignValue(attrs.alignvalue === undefined ? true : (attrs.alignvalue === &quot;true&quot;))
                                        .rightAlignValue(attrs.rightalignvalue === undefined ? false : (attrs.rightalignvalue === &quot;true&quot;))
                                        .noData(attrs.nodata === undefined ? &#039;No Data Available.&#039; : scope.nodata);

                                    if (attrs.xScale) {
                                        chart.xScale(scope.xScale());
                                    }

                                    if (attrs.yScale) {
                                        chart.yScale(scope.yScale());
                                    }

                                    configureXaxis(chart, scope, attrs);
                                    configureYaxis(chart, scope, attrs);
                                    processEvents(chart, scope);
                                    scope.d3Call(data, chart);
                                    nv.utils.windowResize(chart.update);
                                    scope.chart = chart;
                                    return chart;
                                }
                            });
                        }
                    }, (attrs.objectequality === undefined ? false : (attrs.objectequality === &quot;true&quot;)));
                }
            };
        }])
        .directive(&#039;nvd3SparklineWithBandlinesChart&#039;, [function () {
            &#039;use strict&#039;;
            /**
             * http://www.perceptualedge.com/articles/visual_business_intelligence/introducing_bandlines.pdf
             * You need five primary facts about a set of time-series values to construct a bandline:
             * 1) the lowest value,
             * 2) the 25th percentile (i.e., the point at and below which the lowest 25% of the values reside),
             * 3) the median (a.k.a., the 50th percentile, the point at and below which 50% of the values reside),
             * 4) the 75th percentile (i.e., the point at and below which 75% of the values reside), and
             * 5) the highest value.
             */
            return {
                restrict: &#039;EA&#039;,
                scope: {
                    data: &#039;=&#039;,
                    width: &#039;@&#039;,
                    height: &#039;@&#039;,
                    id: &#039;@&#039;,
                    margin: &#039;&amp;&#039;,
                    x: &#039;&amp;&#039;,
                    y: &#039;&amp;&#039;,
                    color: &#039;&amp;&#039;,
                    xscale: &#039;&amp;&#039;,
                    yscale: &#039;&amp;&#039;,
                    showvalue: &#039;@&#039;,
                    alignvalue: &#039;@&#039;,
                    rightalignvalue: &#039;@&#039;,
                    nodata: &#039;@&#039;,

                    xaxistickformat: &#039;&amp;&#039;,
                    yaxistickformat: &#039;&amp;&#039;,

                    //angularjs specific
                    objectequality: &#039;@&#039;,

                    //d3.js specific
                    transitionduration: &#039;@&#039;

                },
                controller: [&#039;$scope&#039;, &#039;$element&#039;, &#039;$attrs&#039;, function ($scope, $element, $attrs) {
                    //expect scope to contain bandlineProperties
                    $scope.d3Call = function (data, chart) {

                        var dataAttributeChartID; //randomly generated if id attribute doesn&#039;t exist
                        var selectedChart;
                        var sLineSelection;
                        var bandlineData;
                        var bandLines;


                        if (!$attrs.id) {

                            dataAttributeChartID = &quot;chartid&quot; + Math.floor(Math.random() * 1000000001);
                            angular.element($element).attr(&#039;data-chartid&#039;, dataAttributeChartID);

                            selectedChart = d3.select(&#039;[data-iem-chartid=&#039; + dataAttributeChartID + &#039;] svg&#039;)
                                .attr(&#039;height&#039;, $scope.height)
                                .attr(&#039;width&#039;, $scope.width)
                                .datum(data);

                            //chart.yScale()($scope.bandlineProperties.median)
                            //var sLineSelection = d3.select(&#039;svg#&#039; + $attrs.id + &#039; g.nvd3.nv-wrap.nv-sparkline&#039;);
                            sLineSelection = d3.select(&#039;[data-iem-chartid=&#039; + dataAttributeChartID + &#039;] svg&#039; + &#039; g.nvd3.nv-wrap.nv-sparkline&#039;);
                            bandlineData = [
                                $scope.bandlineProperties.min,
                                $scope.bandlineProperties.twentyFithPercentile,
                                $scope.bandlineProperties.median,
                                $scope.bandlineProperties.seventyFithPercentile,
                                $scope.bandlineProperties.max
                            ];
                            bandLines = sLineSelection.selectAll(&#039;.nv-bandline&#039;).data([bandlineData]);
                            bandLines.enter().append(&#039;g&#039;)
                                .attr(&#039;class&#039;, &#039;nv-bandline&#039;);

                            selectedChart.transition().duration(($attrs.transitionduration === undefined ? 250 : (+$attrs.transitionduration)))
                                .call(chart);
                        }

                        else {
                            if (!d3.select(&#039;#&#039; + $attrs.id + &#039; svg&#039;)) {
                                d3.select(&#039;#&#039; + $attrs.id)
                                    .append(&#039;svg&#039;);
                            }

                            selectedChart = d3.select(&#039;#&#039; + $attrs.id + &#039; svg&#039;)
                                .attr(&#039;height&#039;, $scope.height)
                                .attr(&#039;width&#039;, $scope.width)
                                .datum(data);

                            //chart.yScale()($scope.bandlineProperties.median)
                            sLineSelection = d3.select(&#039;svg#&#039; + $attrs.id + &#039; g.nvd3.nv-wrap.nv-sparkline&#039;);
                            bandlineData = [
                                $scope.bandlineProperties.min,
                                $scope.bandlineProperties.twentyFithPercentile,
                                $scope.bandlineProperties.median,
                                $scope.bandlineProperties.seventyFithPercentile,
                                $scope.bandlineProperties.max
                            ];
                            bandLines = sLineSelection.selectAll(&#039;.nv-bandline&#039;).data([bandlineData]);
                            bandLines.enter().append(&#039;g&#039;)
                                .attr(&#039;class&#039;, &#039;nv-bandline&#039;);

                            selectedChart.transition().duration(($attrs.transitionduration === undefined ? 250 : (+$attrs.transitionduration)))
                                .call(chart);
                        }
                    };
                }],
                link: function (scope, element, attrs) {
                    scope.$watch(&#039;data&#039;, function (data) {
                        if (data) {
                            //if the chart exists on the scope, do not call addGraph again, update data and call the chart.
                            if (scope.chart) {
                                return scope.d3Call(data, scope.chart);
                            }
                            nv.addGraph({
                                generate: function () {
                                    scope.bandlineProperties = {};
                                    var sortedValues, margin = setupDimensions(scope, attrs, element);
                                    var chart = nv.models.sparklinePlus()
                                        .width(scope.width)
                                        .height(scope.height)
                                        .margin(margin)
                                        .x(attrs.x === undefined ? function (d) { return d.x; } : scope.x())
                                        .y(attrs.y === undefined ? function (d) { return d.y; } : scope.y())
                                        .color(attrs.color === undefined ? nv.utils.getColor([&#039;#000&#039;]) : scope.color())
                                        .showValue(attrs.showvalue === undefined ? true : (attrs.showvalue === &quot;true&quot;))
                                        .alignValue(attrs.alignvalue === undefined ? true : (attrs.alignvalue === &quot;true&quot;))
                                        .rightAlignValue(attrs.rightalignvalue === undefined ? false : (attrs.rightalignvalue === &quot;true&quot;))
                                        .noData(attrs.nodata === undefined ? &#039;No Data Available.&#039; : scope.nodata);

                                    //calc bandline data
                                    scope.bandlineProperties.min = d3.min(data, function (d) { return d[1]; });
                                    scope.bandlineProperties.max = d3.max(data, function (d) { return d[1]; });
                                    sortedValues = data.map(function (d) {
                                        return d[1];
                                    }).sort(function (a, b) {
                                        if (a[0] &lt; b[0]) {
                                            return -1;
                                        } else if (a[0] === b[0]) {
                                            return 0;
                                        } else {
                                            return 1;
                                        }
                                    });

                                    scope.bandlineProperties.twentyFithPercentile = d3.quantile(sortedValues, 0.25);
                                    scope.bandlineProperties.median = d3.median(sortedValues);
                                    scope.bandlineProperties.seventyFithPercentile = d3.quantile(sortedValues, 0.75);

                                    if (attrs.xScale) {
                                        chart.xScale(scope.xScale());
                                    }

                                    if (attrs.yScale) {
                                        chart.yScale(scope.yScale());
                                    }

                                    configureXaxis(chart, scope, attrs);
                                    configureYaxis(chart, scope, attrs);
                                    processEvents(chart, scope);

                                    scope.d3Call(data, chart);

                                    nv.utils.windowResize(chart.update);

                                    scope.chart = chart;
                                    return chart;
                                }
                            });
                        }
                    }, (attrs.objectequality === undefined ? false : (attrs.objectequality === &quot;true&quot;)));
                }
            };
        }]);

    //still need to implement
    //sparkbars??
    //nv.models.multiBarTimeSeriesChart
    //nv.models.multiChart
    //nv.models.scatterPlusLineChart
    //nv.models.linePlusBarWithFocusChart
    //dual y-axis chart

    //crossfilter using $services?
}());</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
